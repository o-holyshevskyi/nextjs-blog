<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Повідомлення в блозі | RSS-канал</title>
        <link>https://oholsyhevskyi.com/uk</link>
        <description>Ласкаво прошу до публікацій мого блогу</description>
        <lastBuildDate>Thu, 14 Dec 2023 14:23:22 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <image>
            <title>Повідомлення в блозі | RSS-канал</title>
            <url>https://o-holyshevskyi.github.io/blog-pic/images/posts/api-testing.png</url>
            <link>https://oholsyhevskyi.com/uk</link>
        </image>
        <copyright>All rights reserved 2023, Oleksandr Holyshevskyi</copyright>
        <item>
            <title><![CDATA[Демістифікація піраміди тестування: план ефективного тестування програмного забезпечення]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/demystifying-testing-pyramid</link>
            <guid>https://oholsyhevskyi.com/uk/blog/demystifying-testing-pyramid</guid>
            <pubDate>Thu, 07 Dec 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

<a name="вступ" id="вступ" />

У середовищі розробки програмного забезпечення, що постійно розвивається, забезпечення надійності та функціональності додатків має першочергове значення. 
Увійдіть у піраміду тестування, парадигму, яка керує розробниками та фахівцями з контролю якості у структуруванні стратегії тестування для досягнення оптимальної ефективності та результативності. 
У цій публікації блогу ми заглибимося в тонкощі піраміди тестування, досліджуючи її рівні, сильні та слабкі сторони, а також те, як використовувати її в процесі розробки.

<a name="огляд-піраміди-тестування" id="огляд-піраміди-тестування" />

Піраміда тестування — це візуальне представлення, яке класифікує тести на три основні рівні: модульні тести в основі,
потім інтеграційні тести посередині та тести інтерфейсу користувача (інтерфейс користувача) у верхній частині. Кожен шар служить певній меті, і піраміда
форма підкреслює розподіл тестів для підтримки здорового балансу.

<a name="модульні-тести" id="модульні-тести" />
<img src="https://o-holyshevskyi.github.io/blog-pic/images/posts/TestingPyramidUnit.png" className="rounded-lg" />

**Сильні сторони**:

- **Деталізованість**: модульні тести зосереджуються на найменших одиницях коду, гарантуючи, що окремі функції чи методи працюють належним чином.
- **Швидкість**: ці тести швидко виконуються, сприяючи швидкому зворотному зв’язку під час розробки.
- **Ізоляція**: модульні тести є ізольованими, що дозволяє розробникам точно виявляти та виправляти проблеми в окремих компонентах, не впливаючи на всю систему.

**Слабкі сторони**:

- **Обмежене охоплення**: незважаючи на те, що модульні тести є ретельними, вони можуть не фіксувати взаємодію між компонентами, що може призвести до відсутності проблем інтеграції.
- **Зайва ізоляція**: надмірна залежність від ізольованих тестів може призвести до хибного відчуття безпеки, оскільки реальні сценарії передбачають взаємодію кількох компонентів.

**Приклад**:

Для веб-додатку модульний тест може перевірити функціональність служби входу, перевіривши, чи правильно перевірено облікові дані користувача.

<a name="інтеграційні-тести" id="інтеграційні-тести" />
<img src="https://o-holyshevskyi.github.io/blog-pic/images/posts/TestingPyramidIntegration.png" className="rounded-lg" />

**Сильні сторони**:

- **Покриття взаємодії**: інтеграційні тести зосереджені на перевірці взаємодії між різними компонентами або службами, виявленні проблем, які модульні тести можуть пропустити.
- **Сценарії реального світу**: ці тести моделюють більш реалістичні сценарії користувача, надаючи ширший погляд на поведінку системи.
- **Раннє виявлення проблем**: інтеграційні тести виявляють проблеми, які виникають під час взаємодії компонентів, запобігаючи їх переростанню в серйозніші проблеми.

**Слабкі сторони**:

- **Повільніше виконання**: порівняно з модульними тестами, інтеграційні тести виконуються довше через їх ширший обсяг.
- **Складність**: розробка ефективних інтеграційних тестів може бути складною, особливо коли мова йде про взаємопов’язані системи.

**Приклад**:

У банківській програмі інтеграційний тест може підтвердити наскрізний процес переказу коштів, гарантуючи, що різні компоненти
(такі як перевірка облікового запису, обробка транзакцій і сповіщення) бездоганно працюють разом.

<a name="тести-інтерфейсу-користувача" id="тести-інтерфейсу-користувача" />
<img src="https://o-holyshevskyi.github.io/blog-pic/images/posts/TestingPyramid.png" className="rounded-lg" />

**Сильні сторони**:

- **Перевірка, орієнтована на користувача**: тести інтерфейсу користувача гарантують, що користувальницький інтерфейс програми працює належним чином, забезпечуючи повне уявлення про взаємодію з користувачем.
- **Наскрізна перевірка**: ці тести охоплюють увесь стек додатків, включаючи серверні служби та зовнішню взаємодію.
- **Реальна взаємодія з користувачем**: тести інтерфейсу користувача імітують дії користувача, пропонуючи зрозуміти, як користувачі взаємодіють із програмою.

**Слабкі сторони**:

- **Крихкість**: тести інтерфейсу користувача можуть бути чутливими до змін у макеті інтерфейсу користувача, що призводить до частих помилок тестування, які не свідчать про фактичні дефекти.
- **Час виконання**: тести інтерфейсу користувача зазвичай повільніші, ніж модульні та інтеграційні тести, що потенційно сповільнює цикл зворотного зв’язку.

**Приклад**:

Для платформи електронної комерції тест інтерфейсу користувача може імітувати шлях користувача від вибору продуктів до додавання їх у кошик
до завершення процесу оформлення замовлення, забезпечуючи безперебійний досвід.

<a name="використання-піраміди-тестування-в-розробці" id="використання-піраміди-тестування-в-розробці" />

**Раннє виявлення проблем**:

- **Модульні тести**: розробники можуть виявляти та виправляти помилки на самому ранньому етапі розробки, забезпечуючи якість коду з самого початку.
- **Інтеграційні тести**: проблеми, що виникають через взаємодію між компонентами, визначаються на етапі розробки, запобігаючи їх просуванню на наступні етапи.

**Оптимізація виконання тесту**:

- **Надайте пріоритет модульним тестам**: оскільки модульні тести є швидшими, вони повинні бути першою лінією захисту під час розробки, надаючи швидкий зворотний зв’язок розробникам.
- **Вибіркові тести інтеграції та інтерфейсу користувача**: рідше запускайте тести інтеграції та інтерфейсу користувача, наприклад під час нічних збірок або перед основними випусками, щоб збалансувати ретельне тестування з ефективними циклами розробки.

**Підтримка працездатного набору тестів**:

- **Регулярний рефакторинг**: періодично переглядайте та перевіряйте тести, щоб переконатися, що вони залишаються актуальними в міру розвитку кодової бази.
- **Уникнення надмірності**: усуньте повторювані тести на різних рівнях, щоб оптимізувати процес тестування та зменшити витрати на обслуговування.

<a name="висновок" id="висновок" />

Піраміда тестування — це потужна структура, яка дає змогу командам розробників створювати надійну стратегію тестування.
Розуміючи сильні та слабкі сторони кожного рівня та стратегічно включаючи їх у процес розробки,
команди можуть знайти баланс між ретельним тестуванням і ефективними циклами розробки.
Прийміть піраміду тестування та підніміть тестування програмного забезпечення на нову висоту, забезпечуючи доставку високоякісних надійних програм для кінцевих користувачів.
]]></description>
        </item>
        <item>
            <title><![CDATA[🌟 Функціональне програмування в автоматизованому тестуванні за допомогою TypeScript і Playwright 🤖🚀 Частина II]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/functional-programming-in-automation-testing-partII</link>
            <guid>https://oholsyhevskyi.com/uk/blog/functional-programming-in-automation-testing-partII</guid>
            <pubDate>Wed, 25 Oct 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

Ласкаво просимо до другої частини нашого дослідження функціонального програмування в автоматизованому тестуванні. У цьому продовженні ми глибше заглибимося в практичну реалізацію концепцій, які вже
<a href="https://oholsyhevskyi.com/uk/blog/functional-programming-in-automation-testing-partI">**обговорювалися досі**</a>. 
Ось що ви можете очікувати в цій частині:

<a name="встановлення-необхідних-бібліотек" id="встановлення-необхідних-бібліотек" />

Ось покрокові інструкції щодо встановлення TypeScript, Playwright і fp-ts. Ми також додамо фрагменти коду та команди, які допоможуть вам у процесі встановлення.
Будь ласка, зверніть увагу, що вам потрібно встановити Node.js, перш ніж продовжити ці інсталяції. Якщо ви ще не встановили Node.js, ви можете завантажити його з офіційного веб-сайту: <a href="https://nodejs.org">**Node.js**</a>

<div name="крок-1-встановіть-typescript" id="крок-1-встановіть-typescript" />

1. Відкрийте інтерфейс командного рядка (CLI) або термінал.
2. Використовуйте Node Package Manager (npm), щоб установити TypeScript глобально:
```bash:cli
npm install -g typescript
```
3. Перевірте встановлення TypeScript, виконавши таку команду:
```bash:cli
tsc --version
```
Ця команда має відобразити встановлену версію TypeScript.

<a name="крок-2-встановіть-playwright" id="крок-2-встановіть-playwright" />

1. Відкрийте свій CLI або термінал.
2. Створіть новий каталог для свого проекту Playwright, якщо ви ще цього не зробили:
```bash:cli
mkdir my-playwright-project-fp
cd my-playwright-project-fp
```
3. Ініціалізуйте новий проект Node.js у своєму каталозі:
```bash:cli
npm init -y
```
4. Встановіть Playwright, виконавши таку команду:
```bash:cli
npm init playwright@latest
```
5. Після встановлення Playwright ви можете використовувати його з JavaScript або TypeScript для автоматизованого тестування. TypeScript рекомендується для безпеки типу.

<a name="крок-3-встановіть-fp-ts-функціональне-програмування-на-typescript" id="крок-3-встановіть-fp-ts-функціональне-програмування-на-typescript"/>

1. Відкрийте свій CLI або термінал.
2. Перейдіть до каталогу вашого проекту (наприклад, my-playwright-project-fp).
3. Встановіть fp-ts як залежність для вашого проекту:
```bash:cli
npm install fp-ts
```
4. Тепер ви можете почати використовувати fp-ts у своєму коді TypeScript. Обов’язково імпортуйте необхідні модулі у ваші файли TypeScript.

<a name="поширені-проблеми-та-усунення-несправностей" id="поширені-проблеми-та-усунення-несправностей" />

1. **Проблема з дозволами**: якщо ви зіткнулися з проблемою з дозволами під час встановлення пакетів, можливо, вам знадобиться використати sudo або налаштувати належні дозволи для встановлення npm.
2. **Версія вузла**: переконайтеся, що у вас встановлено сумісну версію Node.js. Ви можете перевірити свою версію Node.js за допомогою node -v і переконатися, що вона актуальна.
3. **Каталог проекту**: переконайтеся, що ви знаходитесь у правильному каталозі під час виконання команд npm. Під час інсталяції Playwright і fp-ts ви повинні перебувати в каталозі проекту.
4. **Конфігурація TypeScript**: якщо ви збираєтеся використовувати TypeScript із Playwright, вам може знадобитися налаштувати файл конфігурації TypeScript (tsconfig.json) у каталозі вашого проекту, щоб указати, як TypeScript має компілювати ваш код.
Ви можете ініціалізувати файл конфігурації TypeScript за допомогою 'tsc --init' і налаштувати його за потреби.

Пам’ятаючи про ці інсталяції та деякі поширені кроки з усунення несправностей, ви маєте бути на шляху до створення функціональної системи автоматизованого тестування на основі програмування за допомогою TypeScript, Playwright і fp-ts.

<a name="налаштування-проекту" id="налаштування-проекту" />

<a name="структура-проекту" id="структура-проекту" />

Після встановлення необхідних бібліотек, таких як TypeScript, Playwright і fp-ts для вашого проекту автоматизованого тестування, важливо мати добре структурований каталог проекту, щоб ефективно підтримувати ваш код.
Ось типова структура файлу проекту після встановлення необхідних бібліотек:

```css:my-playwright-project-fp/
│
├── node_modules/
├── tests/
│   ├── example.spec.ts
├── tests-examples/
│   ├── demo-todo-app.spec.ts
├── .gitignore
├── package-lock.json
├── package.json
├── playwright.config.ts
├── tsconfig.json
```
Ось розбивка структури проекту:

- **node_modules/**: цей каталог містить бібліотеки та залежності, встановлені для вашого проекту. Вам не потрібно керувати цим каталогом вручну; npm подбає про це.
- **tests/**: цей каталог призначений для ваших загальних сценаріїв тестування. Файл example.spec.ts є ілюстрацією типового тестового сценарію.
- **tests-examples/**: цей каталог, здається, зарезервовано для конкретних прикладів тестів. Файл demo-todo-app.spec.ts містить тестові випадки, пов’язані з демонстрацією програми todo.
- **.gitignore**: цей файл визначає, які файли чи каталоги Git має ігнорувати, коли ви передаєте свій проект системі контролю версій. Це надзвичайно важливо для керування вашим проектом у середовищі з керуванням версіями.
```git:.gitignore
node_modules/
/test-results/
/playwright-report/
/playwright/.cache/
```
- **package-lock.json**: цей файл містить інформацію про точні версії пакетів, встановлених у вашому проекті, забезпечуючи узгодженість між членами команди або на різних машинах.
- **package.json**: цей файл містить метадані про ваш проект і перелік залежностей проекту. Він також включає сценарії npm для запуску тестів, серед іншого.
```json:./package.json
{
  "name": "my-playwright-project-fp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {},
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@playwright/test": "^1.39.0",
    "@types/node": "^20.8.7"
  },
  "dependencies": {
    "fp-ts": "^2.16.1"
  }
}
```
- **playwright.config.ts**: цей файл конфігурації необхідний для налаштування параметрів Playwright, таких як браузери для використання, емуляція пристрою тощо.
```ts:./playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
});
```
Ми можемо спростити нашу конфігурацію Playwright, щоб видалити додаткові проекти (firefox і webkit)
- **tsconfig.json**: файл конфігурації TypeScript визначає, як TypeScript повинен компілювати ваш код. Ви можете налаштувати різні параметри, щоб адаптувати процес компіляції до вимог вашого проекту.
```json:./tsconfig.json
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}
```

Структура вашого проекту організована так, щоб акуратно розмістити ваші тестові сценарії та відповідні конфігурації.
Ви можете створювати додаткові каталоги для службових функцій, об’єктів сторінки або будь-якого іншого допоміжного коду в міру розширення проекту.
Ця структура забезпечує хорошу основу для автоматизованого тестування за допомогою Playwright і TypeScript.

Спробуємо провести наші перші тести 😊:

1. Відкрийте CLI або термінал.
2. Перейдіть до каталогу вашого проекту (наприклад, my-playwright-project-fp).
3. Виконайте перші тести:
```bash:cli
npx playwright test
```
4. Результат:
```bash:cli
2 passed (6.3s)
To open last HTML report run:
  npx playwright show-report
```

Щоб спростити виконання тестів, просто додайте цю команду «npx playwright test» у наш файл package.json у розділі «сценарії»:
```json:./package.json
{
  "name": "my-playwright-project-fp",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "npx playwright test"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@playwright/test": "^1.39.0",
    "@types/node": "^20.8.7"
  },
  "dependencies": {
    "fp-ts": "^2.16.1"
  }
}
```
Тепер ми можемо використовувати просту команду
```bash:cli
npm test
```
Результат:
```bash:cli
2 passed (6.3s)
To open last HTML report run:
  npx playwright show-report
```

<a name="написання-функціональних-тестів" id="написання-функціональних-тестів" />

<a name="тести-на-playwright-за-замовчуванням" id="тести-на-playwright-за-замовчуванням" />

Надані тести Playwright є простими імперативними тестами для перевірки елементів веб-сторінки та взаємодії.
Вони служать хорошою відправною точкою для розуміння можливостей Playwright, але мають деякі недоліки, якщо розглядати їх через призму функціонального програмування:

1. **Імперативний стиль**:
- Тести дотримуються імперативного стилю, де дії вказуються крок за кроком, що може ускладнити код для обґрунтування та підтримки.
2. **Побічні ефекти**:
- Тести включають побічні ефекти, такі як взаємодія зі сторінкою (наприклад, клацання), які зазвичай не рекомендуються у функціональному програмуванні, оскільки вони можуть внести непередбачуваність і вплинути на чистоту тесту.
3. **Відсутність повторного використання**:
- Тести не дуже багаторазові. Якщо вам потрібно виконати подібну дію на іншій сторінці або в кількох тестах, ви можете дублювати код, що призведе до проблем з обслуговуванням.
4. **Обробка тестових даних**:
- Дані, які використовуються в тестах (наприклад, URL-адреси, назви елементів), жорстко закодовані в тестових функціях, що робить їх менш гнучкими та важчими для оновлення, якщо в програмі відбуваються зміни.

<a name="як-перетворити-тести-на-підхід-функціонального-програмування" id="як-перетворити-тести-на-підхід-функціонального-програмування" />

Тепер давайте дослідимо, як можна перетворити ці тести на підхід функціонального програмування за допомогою fp-ts і TypeScript.
Ми зосередимося на створенні більш модульних, багаторазових і чистих функцій.

Трансформовані тести є чудовими прикладами того, як застосувати принципи функціонального програмування до автоматизованого тестування за допомогою TypeScript, Playwright і fp-ts (функціональне програмування на TypeScript).
Ці тести зосереджені на складанні чистих функцій і обробці помилок за допомогою TaskEither.

Ось розбивка підходу функціонального програмування та детальний опис кожного тесту:

**Функціональний підхід**:

У цьому підході ми створили чисті функції, які повертають монади TaskEither. Кожна функція представляє певну дію та складається з використанням функції каналу бібліотеки fp-ts для створення тестових сценаріїв.

- Функція **goto**:
```ts:./tests/example.spec.ts
const goto = (page: Page) => (url: string): TE.TaskEither<void, Page> =>
  TE.tryCatch<void, Page>(
    async () => {
      await page.goto(url);
      return page;
    },
    (error) => {
      throw new Error(error as string);
    }
  );
```
Функція goto приймає об’єкт сторінки Playwright і повертає функцію, яка приймає URL-адресу для переходу. Він інкапсулює логіку для переходу до вказаної URL-адреси. Він повертає TaskEither, який може обробляти помилки.

- Функція **clickGetStarted**:
```ts:./tests/example.spec.ts
const clickGetStarted = (page: Page): TE.TaskEither<void, Page> =>
  TE.tryCatch<void, Page>(
    async () => {
      await page.getByRole('link', { name: 'Get started' }).click();
      return page;
    },
    (error) => {
      throw new Error(error as string);
    }
  );
```
Функція clickGetStarted приймає об’єкт сторінки Playwright і повертає функцію, яка клацає посилання «Почати» на сторінці. Він також повертає TaskEither для керування будь-якими потенційними помилками під час дії.

- Функція **verifyTitle**:
```ts:./tests/example.spec.ts
const verifyTitle = (page: Page) => (expectTitle: RegExp | string): TE.TaskEither<void, void> =>
  TE.tryCatch<void, void>(
    async () => await expect(page).toHaveTitle(expectTitle),
    (error) => {
      throw new Error(error as string);
    }
  );
```
Функція verifyTitle приймає об’єкт сторінки Playwright і очікуваний заголовок (як регулярний вираз або рядок) і повертає функцію, яка перевіряє, чи заголовок сторінки відповідає очікуваному значенню. Він повертає TaskEither.

- Функція **verifyIfHeadingInstallationElementIsVisible**:
```ts:./tests/example.spec.ts
const verifyIfHeadingInstallationElementIsVisible = (page: Page): TE.TaskEither<void, void> =>
  TE.tryCatch<void, void>(
    async () => {
      await expect(page.getByRole('heading', { name: 'Installation' })).toBeVisible();
    },
    (error) => {
      throw new Error(error as string);
    }
  );
```
Ця функція перевіряє, чи відображається на сторінці елемент заголовка «Встановлення». Він приймає об’єкт сторінки Playwright і повертає TaskEither.

**Тестові випадки**:

У тестах використовується функція каналу з fp-ts для послідовного створення дій. Ось детальний опис кожного тесту:

- "**has title fp**" Тест:
```ts:./tests/example.spec.ts
test('has title fp', async ({ page }) => {
  await F.pipe(
    goto(page)('https://playwright.dev/'),
    TE.chain((page) => verifyTitle(page)(/Playwright/))
  )();
});
```
- Тест переходить до URL-адреси "https://playwright.dev/" за допомогою функції goto.
- Потім він перевіряє, що заголовок сторінки містить рядок "Playwright" за допомогою функції verifyTitle із регулярним виразом.
- Усі дії складаються з використанням TE.chain для обробки помилок і забезпечення чистоти та передбачуваності тесту.

- "**get started link fp**" Тест:
```ts:./tests/example.spec.ts
test('get started link fp', async ({ page }) => {
  await F.pipe(
    goto(page)('https://playwright.dev/'),
    TE.chain((page) => clickGetStarted(page)),
    TE.chain((page) => verifyIfHeadingInstallationElementIsVisible(page))
  )();
});
```
- Цей тест також починається з переходу до 'https://playwright.dev/' за допомогою функції goto.
- Потім клацає посилання «Почати» за допомогою функції clickGetStarted.
- Нарешті, він перевіряє, чи видимий елемент заголовка "Installation" за допомогою функції verifyIfHeadingInstallationElementIsVisible.
- Як і в першому тесті, він використовує TE.chain для послідовності дій і обробки помилок.

**Обробка помилок**:

Кожна функція включає обробку помилок за допомогою TE.tryCatch. У разі помилок він видає повідомлення про помилку з описовим повідомленням, гарантуючи, що помилки обробляються контрольованим способом.

Цей функціональний підхід добре узгоджується з принципами функціонального програмування, наголошуючи на використанні чистих функцій, композиції та керування помилками. Це призводить до більш зручного та передбачуваного тестового коду, що полегшує написання та налагодження складних тестових сценаріїв.
Крім того, він забезпечує гнучкість для ефективної обробки помилок і надання значущих повідомлень про помилки.

<a name="передові-методи" id="передові-методи"/>

Передові методи функціонального програмування можуть значно покращити автоматизоване тестування, зробивши ваш тестовий код більш надійним, придатним для обслуговування та ефективним.
Ось кілька передових методів і концепцій, які можна застосувати до автоматизованого тестування в рамках парадигми функціонального програмування:

1. **Функції вищого порядку (HOF)**:
- HOF - це функції, які приймають інші функції як аргументи або повертають функції як результати. Під час автоматизованого тестування ви можете створювати функції вищого порядку для інкапсуляції загальних тестових шаблонів.
Наприклад, ви можете створити функцію вищого порядку для обробки автентифікації, налаштування даних або навігації сторінками, зробивши ваші тести більш модульними та СУХИМИ (не повторюйтеся).
2. **Функціональний склад**:
- Функціональна композиція - це акт поєднання двох або більше функцій для отримання нової функції. Під час тестування ви можете створювати функції для створення складних тестових сценаріїв.
Це дозволяє повторно використовувати та комбінувати менші чисті функції для ефективного створення комплексних тестів.
3. **Монади та функтори**:
- Монади та функтори — це передові концепції функціонального програмування, які можна застосовувати для обробки послідовності та обробки помилок у тестах.
Такі бібліотеки, як fp-ts, надають такі монади, як Task і TaskEither, для ефективного керування асинхронними діями та помилками.
4. **Незмінність**:
- Незмінність є основним принципом функціонального програмування. Незмінні структури даних, як і постійні структури даних, можна використовувати для представлення та обробки тестових даних.
Це гарантує, що тестові дані залишаються узгодженими під час виконання тесту, підвищуючи надійність.
5. **Часткове нанесення та каррірування**:
- Часткове застосування та каррінг дозволяють створювати функції з кількома параметрами крок за кроком, полегшуючи передачу конфігурацій і залежностей у ваші тестові функції.
Це покращує обробку тестових даних і гнучкість.
6. **Безпека типу та статичний аналіз**:
- Використовуйте TypeScript або інші статично типізовані мови для свого коду тестування. Статична типізація гарантує, що ваш код відповідає очікуваним типам даних, зменшуючи помилки, пов’язані з типами, і роблячи ваші тести більш надійними.
7. **Чисті функції**:
- Функціональне програмування заохочує використання чистих функцій, які створюють той самий вихід для того самого входу. Написання чистих функцій для ваших тестових дій забезпечує передбачуваність, легке тестування та надійні тестові налаштування.

Включивши ці передові методи функціонального програмування у своє автоматизоване тестування, ви можете створити тестовий код, який є більш надійним, придатним для обслуговування та адаптацією.
Це також допомагає оптимізувати розробку тестових прикладів, покращити повторне використання коду та підвищити загальну якість вашої системи тестування.

<a name="як-розширити-існуючі-тести-за-допомогою-фіксутр" id="як-розширити-існуючі-тести-за-допомогою-фіксутр"/>

Поточна проблема з визначенням цих функцій (наприклад, **goto**, **clickGetStarted**, **verifyTitle** і **verifyIfHeadingInstallationElementIsVisible**) в одному тестовому файлі полягає в тому, що це порушує принципи модульності, багаторазове використання та поділ проблем.
Ось чому вам варто розглянути можливість використання фікстур і переміщення цих функцій в окремі модулі:

1. **Порушення розподілу завдань**: збереження цих функцій у тестовому файлі ускладнює відокремлення питань налаштування та взаємодії зі сторінкою від фактичної логіки тестування.
Це порушує принцип поділу проблем, що може призвести до менш зручного обслуговування та більш складного коду.
2. **Дублювання коду**: якщо у вас є кілька тестових файлів, які повинні виконувати однакові дії (наприклад, перехід на сторінку, клацання посилання), ви в кінцевому підсумку дублюєте ці функції в кількох тестових файлах.
Це не тільки збільшує надлишковість коду, але й ускладнює підтримку та оновлення коду, коли потрібні зміни.
3. **Неможливість повторного використання**: такі функції, як goto, clickGetStarted і verifyTitle, є загальними діями, які можна повторно використовувати в кількох тестових файлах. Централізувавши ці дії, ви сприяєте повторному використанню та зручності обслуговування.
4. **Test Fixture**: використання фікстури в Playwright забезпечує спеціальне та структуроване середовище для налаштування екземплярів і сторінок браузера та керування ними.
Перемістивши ці функції в прилад, ви можете гарантувати, що кожен тест починається з чистого та передбачуваного стану. Це також покращує ізоляцію ваших тестів, роблячи їх більш надійними.
5. **Організація коду**: переміщення цих функцій в окремі модулі дозволяє більш ефективно організувати ваш код.
Ви можете створити спеціальний модуль для дій, модуль для тестових приладів і інший для реальних тестів. Це розділення покращує читабельність і зручність обслуговування вашої кодової бази.
6. **Співпраця**: під час роботи в команді стандартизований підхід до налаштування та дій тестування, як це передбачено фікстурами та централізованими модулями, гарантує, що всі дотримуються однакових практик.
Це покращує співпрацю та полегшує розуміння та розширення набору тестів.

Щоб покращити свій підхід, розгляньте наступні кроки:

1. Створіть спеціальний пристрій для налаштування тестового середовища, яке включає запуск браузера та створення сторінки.
2. Визначте окремі модулі для дій, які ви хочете виконати (наприклад, навігація, взаємодія, перевірка).
3. Використовуйте кріплення у ваших тестових файлах, щоб налаштувати середовище перед кожним тестом.
4. Створіть дії з ваших модулів дій у ваших тестових функціях.

Прийнявши цей підхід, ви отримаєте більш модульний код, який можна багаторазово використовувати та підтримувати, який відповідає найкращим практикам автоматизації тестування.
Він сприяє організації коду, спільному використанню коду та стандартизації, що зрештою робить ваші спроби тестування ефективнішими та надійнішими.

<a name="створіть-спеціальну-фікстуру" id="створіть-спеціальну-фікстуру"/>

Давайте створимо спеціальну програму для налаштування вашого тестового середовища, яка включає створення екземпляра цільової сторінки.
Створіть нову папку **fixtures** у папці **tests** з файлом **fixture.ts**: тепер структура проекту така:
```css:my-playwright-project-fp/
│
├── node_modules/
├── tests/
│   ├── fixtures/
│   │   ├── fixture.ts
│   ├── example.spec.ts
├── .gitignore
├── package-lock.json
├── package.json
├── playwright.config.ts
├── tsconfig.json
```

Щоб створити нашу фікстуру, давайте почнемо з імпорту необхідних залежностей:
```ts:./tests/fixtures/fixture.ts
import { test as base } from '@playwright/test';
```
Визначте тип фікстури, який представляє її структуру. У цьому випадку він включає властивість landingPage типу LandingPage, який є типом, пов’язаним із цільовою сторінкою вашої програми.
```ts:./tests/fixtures/fixture.ts
import { test as base } from '@playwright/test';

type Fixture = {
  landingPage: LandingPage;
};
```
Створіть тестову фікстуру за допомогою base.extend. Цей метод розширює базовий набір тестів додатковими функціями. Тут ви розширюєте його за допомогою фікстури, яке налаштує вашу цільову сторінку.

```ts:./tests/fixtures/fixture.ts
import { test as base } from '@playwright/test';

type Fixture = {
  landingPage: LandingPage;
};
export const test = base.extend<Fixture>({
  landingPage: async ({ page }, use) => {
    const landing = landingPage(page);
    await use(landing);
    await page.close();
  }
});
```
У визначенні фіксутри:
- Ви надаєте функцію зворотного виклику, яка приймає два аргументи: **page** і **use**. **сторінка** — це об’єкт **Сторінка** Playwright, а **використання** — це функція, яка дозволяє передавати дані налаштування
(у цьому випадку об’єкт **landingPage**) до тестів, які використовують цей фікстур.
- Ви створюєте екземпляр **LandingPage** за допомогою функції **landingPage**, передаючи об’єкт **page**.
- Ви передаєте об’єкт **landing** у функцію **use**. Це дозволяє тестам, які використовують цей прилад, отримувати доступ до об’єкта **landingPage**.
- Нарешті, ви закриваєте **сторінку**, щоб очистити після тесту. Це важливо для підтримки чистого та ізольованого тестового середовища.

Експортуйте функцію очікування з бібліотеки @playwright/test. Ця функція дозволяє робити твердження у ваших тестових випадках.

```ts:./tests/fixtures/fixture.ts
import { test as base } from '@playwright/test';

type Fixture = {
  landingPage: LandingPage;
};
export const test = base.extend<Fixture>({
  landingPage: async ({ page }, use) => {
    const landing = landingPage(page);
    await use(landing);
    await page.close();
  }
});

export { expect } from '@playwright/test';
```
Тепер у вас можуть виникнути деякі помилки, оскільки ми не використовуємо **Цільову сторінку** та **цільову сторінку**.

<a name="визначте-окремі-модулі-для-дій" id="визначте-окремі-модулі-для-дій"/>

Давайте визначимо окремі модулі для дій, які ви хочете виконувати, наприклад навігацію, взаємодію та перевірку.
Створіть нову папку **src** у корені. Потім створіть папку **pages**, що означає, що ми розмістимо всі сторінки в одній папці.

Потім створіть файл **landing-page.ts** у папці **pages**.
```css:my-playwright-project-fp/
│
├── node_modules/
├── src/
│   ├── pages/
│   │   ├── landing-page.ts
├── tests/
│   ├── fixtures/
│   │   ├── fixture.ts
│   ├── example.spec.ts
├── .gitignore
├── package-lock.json
├── package.json
├── playwright.config.ts
├── tsconfig.json
```
Щоб створити наші окремі модулі, давайте почнемо з імпорту необхідних залежностей:
```ts:./src/pages/landing-page.ts
import { PageOf } from "./pages";
```
Заява про імпорт:
Цей рядок імпортує тип або інтерфейс під назвою **PageOf** з модуля, розташованого у відносному шляху до файлу **./pages**.

Тепер нам потрібно створити один додатковий тип **PageOf**.
Створіть файл **pages.ts** у папці **pages**.
```css:my-playwright-project-fp/
│
├── node_modules/
├── src/
│   ├── pages/
│   │   ├── landing-page.ts
│   │   ├── pages.ts
├── tests/
│   ├── fixtures/
│   │   ├── fixture.ts
│   ├── example.spec.ts
├── .gitignore
├── package-lock.json
├── package.json
├── playwright.config.ts
├── tsconfig.json
```
Щоб створити наш тип, ми визначаємо наступний код:
```ts:./src/pages/pages.ts
import { Page } from '@playwright/test';

export type PageOf<T> = (page: Page) => T;
```
Модуль **pages.ts** зосереджений на визначенні типу **{'PageOf<T>'}**, який є загальним типом. Давайте зануримося глибше в цей модуль:
1. **Імпорт**:
- Модуль імпортує тип сторінки з середовища Playwright. Цей тип представляє об’єкт сторінки Playwright.
2. **Визначення типу**:
- Визначення типу **{'PageOf<T>'}** є загальним типом, який приймає тип **T**. Цей тип представляє функцію, яка приймає Playwright **Page** і повертає об’єкт типу **T**.
Цей шаблон зазвичай використовується для визначення об’єктів сторінки або інтерфейсів елементів.

Створюючи цей тип, ви встановлюєте контракт, який передбачає, що будь-яка функція типу **{'PageOf<T>'}** повинна повертати об’єкт, що відповідає типу **T**, що допомагає забезпечити узгодженість у ваших об’єктних моделях сторінки. .

Повернемося до реалізації нашого модуля дій для цільової сторінки у файлі **landing-page.ts**.
```ts:./src/pages/landing-page.ts
import { PageOf } from "./pages";

export interface LandingPage {

}
```
Інтерфейси та типи:
Інтерфейс **LandingPage** виглядає як заповнювач для визначення елементів і дій, характерних для цільової сторінки. У об’єктних моделях сторінок зазвичай створюють такі інтерфейси для визначення структури сторінки.

```ts:./src/pages/landing-page.ts
import { PageOf } from "./pages";

export interface LandingPage {

}

export const landingPage: PageOf<LandingPage> = (page) => {
    return {

    };
}
```
Функція **landingPage**:
Функція **landingPage** експортується з цього модуля. Він приймає Playwright **Page** як аргумент і повертає об’єкт, який відповідає інтерфейсу **LandingPage**.
Ця функція, по суті, є фабричною функцією для створення екземплярів POM цільової сторінки.

Функція landingPage, викликана зі сторінкою, має повертати об’єкт, який надає методи та властивості для взаємодії з елементами на цільовій сторінці.
Ці методи можуть включати такі дії, як натискання кнопок, заповнення форм і перевірка елементів.

Підводячи підсумок, модуль **landingPage** призначений для інкапсуляції структури та дій, пов’язаних із конкретною сторінкою (в даному випадку це цільова сторінка).
Він використовує функцію **landingPage** для створення екземплярів цієї сторінки з методами взаємодії з елементами.
Модуль **pages.ts** визначає тип (**{'PageOf<T>'}**) для забезпечення виконання контракту для об’єктів сторінки та підтримки безпеки типу.

За допомогою такого підходу ви можете створювати подібні модулі для інших сторінок у вашій програмі, в результаті чого ви отримаєте добре структурований і модульний набір тестів.
Ці модулі допомагають розділити вашу тестову логіку та взаємодію сторінок, роблячи автоматизовані тести більш організованими та простішими в обслуговуванні.

<a name="використовуйте-фікстури-в-тестових-файлах" id="використовуйте-фікстури-в-тестових-файлах"/>

Щоб використовувати наш фікстури зі створеними модулями в наших тестах, давайте перемістимо визначені методи з файлу **example.spec.ts** у наш файл **landing-page.ts**.
```ts:./src/pages/landing-page.ts
import { expect } from "../../tests/fixtures/fixture";
import { PageOf } from "./pages";
import * as TE from 'fp-ts/TaskEither';

export interface LandingPage {
  goto: (url: string) => TE.TaskEither<void, void>;
  clickGetStarted: () => TE.TaskEither<void, void>;
  verifyTitle: (title: RegExp | string) => TE.TaskEither<void, void>;
}

export const landingPage: PageOf<LandingPage> = (page) => {
  return {
    goto: (url): TE.TaskEither<void, void> => 
      TE.tryCatch(
        async () => { await page.goto(url) },
        (error) => { throw new Error(error as string) }
      ),
    clickGetStarted: (): TE.TaskEither<void, void> => 
      TE.tryCatch(
        async () => page.getByRole('link', { name: 'Get started' }).click(),
        (error) => {
        throw new Error(error as string);
        }
      ),
    verifyTitle: (title): TE.TaskEither<void, void> => 
      TE.tryCatch(
        async () => await expect(page).toHaveTitle(title),
        (error) => {
          throw new Error(error as string);
        }
      ),
  };
}
```
Ми створили окремий модуль під назвою landing-pages.ts, щоб інкапсулювати дії та функції, пов’язані з цільовою сторінкою вашої програми.
Цей підхід сприяє модульності та багаторазовому використанню, що узгоджується з принципами функціонального програмування. Давайте розберемо ваш модуль і його компоненти:

1. **Залежності та типи імпорту**:
- Ви починаєте з імпорту необхідних залежностей і типів, на які покладається ваш модуль.
Це включає імпорт **expect** для тверджень, **PageOf** з модуля **pages** і монади **TE** (TaskEither) з **fp-ts** для обробки асинхронних дій і потенційних помилки.
2. **Визначте інтерфейс LandingPage**:
- Ви визначаєте інтерфейс під назвою **LandingPage**, який визначає структуру дій цільової сторінки. Цей інтерфейс описує три ключові дії для цільової сторінки: **goto**, **clickGetStarted** і **verifyTitle**.
3. **Створіть функцію landingPage**:
Ця функція служить фабричною функцією, яка створює об’єкт **LandingPage**. Він приймає об’єкт **page** як параметр, який представляє сторінку Playwright, де виконуватимуться ці дії.
Ця функція повертає об’єкт із визначеними діями.
4. **Визначення дій**:
- У функції **landingPage** ви визначаєте три дії:
  - **goto**: ця функція переходить до вказаної URL-адреси та повертає **TaskEither** для обробки помилок.
  - **clickGetStarted**: ця функція натискає посилання «Почати», а також повертає TaskEither.
  - **verifyTitle**: ця функція перевіряє, чи заголовок сторінки відповідає наданому регулярному виразу або рядку, і повертає **TaskEither**.

Кожна з цих функцій дій використовує TE.tryCatch для акуратної обробки помилок і гарантує, що будь-які помилки фіксуються та повідомляються. Цей підхід узгоджується з функціоналом
принципи програмування, зберігаючи чисті дії, відокремлюючи проблеми та інкапсулюючи функціональність у модульний спосіб.

Структуруючи свій код таким чином, ви сприяєте повторному використанню, зручності обслуговування та ізоляції тестів. Тепер цей модуль можна легко імпортувати та використовувати в різних тестових файлах для послідовної та надійної взаємодії з цільовою сторінкою.
Це також сприяє співпраці та узгодженості коду, коли кілька членів команди працюють над одним проектом. Тож давайте імпортуємо наш модуль у тестовий файл.

```ts:./tests/example.spec.ts
import { test } from './fixtures/fixture';
import * as TE from 'fp-ts/TaskEither';
import * as F from 'fp-ts/function';

test('has title fp', async ({ landingPage }) => {
  await F.pipe(
    landingPage.goto('https://playwright.dev/'),
    TE.chain(() => landingPage.verifyTitle(/Playwright/))
  )();
});
```
У вашому тестовому файлі ви успішно імпортували модуль landingPage та інтегрували його у свої тестові випадки відповідно до парадигми функціонального програмування. Ось детальне пояснення тестового коду:

1. **Тестовий імпорт**:
- Ви починаєте з імпорту функції **test** із вашого тестового приладу, який надає тестове середовище Playwright і фікстуру **landingPage**.
2. **Функціональний склад**:
- Ви використовуєте функцію **F.pipe** для створення послідовності дій. Функція **pipe** дозволяє вам виконувати функції в конвеєрі, де вихідні дані однієї функції передаються як вхідні дані для наступної функції.
3. **landingPage.goto('https://playwright.dev/')**:
- Ця дія складається спочатку. Він використовує фікстуру **landingPage** для переходу до URL-адреси «https://playwright.dev/». Функція **goto** повертає **TaskEither**, що представляє дію навігації.
4. **TE.chain(() => landingPage.verifyTitle(/Playwright/))**:
- Функція **TE.chain** використовується для ланцюжка наступної дії. У цьому випадку це функція **verifyTitle**. Функція **verifyTitle** перевіряє, чи заголовок сторінки відповідає регулярному виразу **/Playwright/**.
Якщо перевірка заголовка вдається, вона повертає **TaskEither**, що вказує на успіх.
5. **()(); - Виконайте складені дії**:
- Кінцевий **()();** в кінці композиції використовується для виконання складених дій. Цей шаблон часто можна побачити у функціональному програмуванні з асинхронними операціями.
Це спосіб ініціювати виконання складених функцій і переконатися, що будь-які помилки належним чином обробляються монадою **TaskEither**.

Побудувавши свій тест таким чином, ви досягли таких переваг:

- **Модульність**: дії для переходу до URL-адреси та перевірки заголовка інкапсульовані в фікстурі **landingPage**, сприяючи модульності коду та повторному використанню.
- **Функціональна композиція**: ви використали функціональну композицію для створення послідовності дій, завдяки чому ваш тестовий код став більш декларативним і легшим для читання.
- **Обробка помилок**: помилки витончено обробляються за допомогою монади **TaskEither**, гарантуючи, що будь-які помилки під час тестування фіксуються та можуть бути керовані передбачуваним способом.
- **Ізоляція тестів**: завдяки використанню фіксаторів і модульного підходу кожен тест може починатися з чистого стану, сприяючи ізоляції тестів і знижуючи ймовірність перешкод між тестами.

Цей підхід добре узгоджується з принципами функціонального програмування та забезпечує структурований і організований спосіб написання зручних і надійних тестів.

Але зачекайте, є одна річ, яку ми ще не зробили. Для другого тесту потрібен інший модуль для сторінки «Почати», спробуйте реалізувати його самостійно

<a name="висновок" id="висновок"/>

Ключові висновки з цих двох публікацій:

1. **Принципи функціонального програмування**:
- Функціональне програмування сприяє використанню чистих функцій, незмінності та компонування, що призводить до більш надійного та придатного для обслуговування тестового коду автоматизації.
2. **Модульна структура тесту**:
- Структурування тестового коду за допомогою модульних компонентів, таких як кріплення та окремі модулі дій, покращує організацію коду та можливість повторного використання.
3. **fp-ts для обробки помилок**:
- Використання бібліотеки fp-ts, зокрема TaskEither, для обробки помилок забезпечує послідовне та передбачуване керування помилками у ваших тестових сценаріях.
4. **Пристосування та параметри пристосувань**:
- Механізм фікстури Playwright дозволяє створювати стандартизовані тестові налаштування, а параметри фікстур дозволяють передавати багаторазові дії та конфігурації до ваших тестів.
5. **Відокремлення концернів**:
- Відокремлення проблем у вашому тестовому коді, наприклад ізоляції тестових дій від тестової логіки, спрощує налагодження та сприяє співпраці у великих проектах.
6. **Статичний набір із TypeScript**:
- TypeScript забезпечує статичну типізацію, що покращує якість коду, запобігає помилкам, пов’язаним із типом, і підвищує загальну надійність ваших тестів.
7. **Повторне використання та ремонтопридатність**:
- Функціональне програмування та модульні структури коду спрощують повторне використання тестів, спрощуючи підтримку та розширення набору тестів у міру розвитку програми.
8. **Склад функціонального тесту**:
- Компонування чистих функцій для тестових дій гарантує, що ваші тестові сценарії будуються з менших багаторазово використовуваних компонентів, що забезпечує більш читабельні та ефективні тести.
9. **Обробка помилок і звітування**:
- Техніка функціонального програмування дозволяє структуровано обробляти помилки та звітувати, забезпечуючи чіткість та інформативність помилок тестування.
10. **Тестова ізоляція**:
- Використання кріплень і модульного підходу допомагає досягти ізоляції тестів, коли кожен тест починається з чистого стану, зменшуючи перешкоди між тестовими випадками.

Таким чином, застосування концепцій функціонального програмування, модульної організації коду та використання TypeScript і Playwright в автоматизованому тестуванні призводить до тестів, які є більш надійними, доступними для обслуговування та ефективними.
Ці методи сприяють співпраці та узгодженості коду в командних середовищах, що призводить до високоякісного набору тестів для ваших веб-додатків.

<a name="додаткові-ресурси" id="додаткові-ресурси"/>

Ось кілька додаткових ресурсів, книг і веб-сайтів, де ви можете розширити свої знання про функціональне програмування, TypeScript, fp-ts і Playwright:

**Функціональне програмування**:
- **"Функціональне програмування в JavaScript" Луїса Атенсіо**: ця [**книга**](https://medium.com/@luijar/functional-programming-in-javascript-d7cc3d78d463) досліджує концепції функціонального програмування в JavaScript, які також мають велике відношення до TypeScript.
- **"Функціональне програмування в Scala" Пола К'юзано та Рунара Б'ярнасона**: Хоча [**книга**](https://books.google.com.ua/books/about/Functional_Programming_in_Scala.html?id=GjszEAAAQBAJ&redir_esc=y) фокусується на Scala, забезпечує глибоке занурення в концепції функціонального програмування, які можна застосувати до TypeScript.
- **Функціональне програмування за допомогою TypeScript**: цей [**онлайн-курс**](https://www.youtube.com/playlist?list=PLuPevXgCPUIMbCxBEnc1dNwboH6e2ImQo) охоплює принципи функціонального програмування.

**TypeScript**:
- **Офіційний довідник з TypeScript**: [**офіційний довідник**](https://www.typescriptlang.org/docs/handbook/intro.html) містить повну документацію про TypeScript, включаючи ключові поняття та практичні приклади.
- **"Програмування TypeScript" Бориса Черного**: ця [**книга**](https://books.google.com.ua/books?id=Y-mUDwAAQBAJ&printsec=copyright&redir_esc=y#v=onepage&q&f=false) є цінним ресурсом для вивчення TypeScript, який охоплює як основні, так і складні теми.
- **TypeScript Deep Dive (онлайн-книга)**: [**поглиблений посібник**](https://react-etc.net/files/typescript-book/typescript.pdf) з TypeScript, доступний онлайн безкоштовно, охоплюючи розширені функції TypeScript і найкращі практики.

**fp-ts (функціональне програмування на TypeScript)**:
- **fp-ts GitHub Repository**: [**офіційне сховище**](https://github.com/gcanti/fp-ts) містить документацію, приклади коду та ресурси для fp-ts.
- **"Функціональне програмування на TypeScript" на Medium**: [**серія статей**](https://medium.com/search?q=Functional+Programming+in+TypeScript) від творця fp -ts, Джуліо Канті, пояснюючи різні концепції та техніки в fp-ts.

**Драматург**:
- **Офіційна документація Playwright**: [**офіційна документація**](https://playwright.dev/docs/intro) — це повний ресурс для початку роботи з Playwright, включаючи навчальні посібники та посилання на API.
- **Playwright with TypeScript на Dev.to**: [**Статті та навчальні посібники**](https://dev.to/search?q=Playwright%20with%20TypeScript) про використання Playwright з TypeScript, включаючи розширене тестування техніки.

**Сховище GitHub**
- [**зразок**](https://github.com/o-holyshevskyi/my-playwright-project-fp) проекту, який ми створили в цій публікації;
]]></description>
        </item>
        <item>
            <title><![CDATA[🌟 Функціональне програмування в автоматизованому тестуванні за допомогою TypeScript і Playwright 🤖🚀 Частина I]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/functional-programming-in-automation-testing-partI</link>
            <guid>https://oholsyhevskyi.com/uk/blog/functional-programming-in-automation-testing-partI</guid>
            <pubDate>Sun, 22 Oct 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

<a name="вступ" id="вступ" />

<a name="функціональне-програмування-в-автоматизованому-тестуванні" id="функціональне-програмування-в-автоматизованому-тестуванні" />

Функціональне програмування в автоматизованому тестуванні — це парадигма, яка використовує принципи функціонального програмування для розробки та написання тестових сценаріїв.
На відміну від традиційних імперативних підходів до тестування, функціональне програмування зосереджується на створенні тестових випадків як чистих функцій, наголошуючи на незмінності та можливості компонування.
Використовуючи такі технології, як TypeScript і Playwright, тестувальники можуть створювати надійні, зручні в обслуговуванні та добре читабельні тестові структури.
Цей підхід пропонує численні переваги, включаючи покращену якість коду, розширене охоплення тестуванням і підвищену ефективність автоматизації тестування.
У цій публікації ми глибше заглибимося у світ функціонального програмування для автоматизованого тестування, досліджуючи його переваги та практичну реалізацію.

<a name="чому-typescript-і-playwright" id="чому-typescript-і-playwright" />

Використання TypeScript і Playwright для створення тестового фреймворку має значні переваги в контексті автоматизованого тестування:

1. Надійна типізація TypeScript: TypeScript забезпечує статичну типізацію, що означає, що ви виловлюєте помилки під час компіляції, а не під час виконання.
Це зменшує ймовірність появи помилок у тестовому коді та покращує якість коду. Він також пропонує доповнення коду та кращу документацію коду, що полегшує написання та підтримку тестових сценаріїв.
2. Супроводжуваність: TypeScript дотримується суворих стандартів кодування та найкращих практик, що призводить до більш зручного обслуговування коду. Оскільки автоматизовані тести часто живуть довго, це має вирішальне значення для довговічності вашої тестової структури.
3. Читабельність коду: надійна типізація та чистіший синтаксис TypeScript покращують читабельність коду. Це особливо важливо під час тестування, де чітко та зрозуміло
тестові сценарії можуть заощадити час і скоротити криву навчання для нових членів команди.
4. Підтримка різних браузерів Playwright: Playwright — це потужна бібліотека автоматизації, яка підтримує кілька браузерів (Chromium, Firefox і WebKit).
Ця крос-браузерна сумісність дозволяє вам запускати ті самі тести в різних браузерах, забезпечуючи надійність ваших тестів на різних платформах.
5. Продуктивність і надійність: Playwright відомий своєю швидкістю та надійністю у виконанні тестів.
Він пропонує безголовий режим для швидшого тестування та має вбудовану обробку помилок, що робить його більш надійним у обробці динамічних веб-додатків.
6. Уніфікований API: Playwright надає уніфікований API для автоматизації різних браузерів. Це означає, що ви можете написати тести один раз і запустити їх у кількох браузерах, зменшуючи зусилля, необхідні для крос-браузерного тестування.
7. Тестування доступності: Playwright містить функції для тестування доступності, що має вирішальне значення для забезпечення того, що веб-програми придатні для використання всіма користувачами, включно з особами з обмеженими можливостями.
8. Екосистема та спільнота: TypeScript і Playwright підтримуються сильними спільнотами розробників і мають обширну документацію, що полегшує пошук підтримки, ресурсів і плагінів/розширень для різних потреб тестування.
9. Інтеграція з CI/CD: TypeScript і Playwright можуть бути легко інтегровані в конвеєри безперервної інтеграції/безперервного розгортання (CI/CD), що дозволяє автоматизувати тестування в життєвому циклі розробки програмного забезпечення.

Підсумовуючи, TypeScript і Playwright разом забезпечують надійне, зручне та ефективне рішення для створення тестової структури.
Вони підвищують якість коду, крос-браузерну сумісність і загальну ефективність тестування, що робить їх цінними інструментами для автоматизованого тестування.

<a name="що-охоплює-ця-публікація" id="що-охоплює-ця-публікація" />

У цій публікації ми розглянемо основи функціонального програмування в контексті автоматизованого тестування. Ми почнемо з пояснення основних принципів функціонального програмування та того, як їх можна застосувати до тестування.

Потім ми проведемо вас через встановлення необхідних бібліотек, зокрема TypeScript і Playwright, надавши покрокові інструкції та фрагменти коду, щоб зробити процес налаштування простим.

Далі ми заглибимося в налаштування проекту для вашого тестового фреймворку. Ми обговоримо структуру проекту, організацію файлів і основні компоненти, необхідні для того, щоб налагодити роботу вашого середовища тестування.
Ви можете очікувати, що побачите практичні приклади коду, які демонструють кожен крок, що полегшить наслідування та впровадження концепцій у власні проекти.

До кінця цієї публікації ви матимете чітке розуміння принципів функціонального програмування в автоматизованому тестуванні, повністю настроєне середовище тестування з TypeScript і Playwright,
і знання, щоб почати писати ефективні тестові сценарії, які зручно підтримувати.

<a name="що-таке-функціональне-програмування" id="що-таке-функціональне-програмування" />

Функціональне програмування — це парадигма програмування, яка розглядає обчислення як оцінку математичних функцій і уникає зміни стану або змінних даних.
Він наголошує на використанні чистих функцій, незмінності та функцій вищого порядку для структурування та вирішення проблем.
У функціональному програмуванні програми створюються шляхом компонування функцій, що сприяє створенню коду, який є більш передбачуваним, придатним для обслуговування та легшим для міркування.

<a name="основні-принципи-функціонального-програмування" id="основні-принципи-функціонального-програмування" />

Ось пояснення основних принципів функціонального програмування:

1. Незмінність:
- Незмінність відноситься до концепції, згідно з якою дані після створення не можуть бути змінені. Замість того, щоб змінювати існуючі дані, ви створюєте нові структури даних.
- У функціональному програмуванні незмінність гарантує, що функції не мають побічних ефектів, полегшуючи міркування та налагодження коду.
- Незмінні дані безпечні для потоків, що особливо важливо в паралельному або паралельному програмуванні.
2. Чисті функції:
- Чисті функції - це функції, які, маючи той самий вхід, завжди дають той самий вихід без зміни будь-якого зовнішнього стану чи змінних.
- Вони не мають побічних ефектів, тобто не змінюють жодних даних поза межами функції.
- Чисті функції передбачувані та тестовані, що полегшує налагодження та тестування.
3. Функції вищого порядку:
- Функції вищого порядку - це функції, які можуть приймати інші функції як аргументи або повертати функції як результати.
- Вони дозволяють абстракцію та повторне використання коду. Загальні приклади функцій вищого порядку включають map, filter і reduce, які працюють з масивами та дозволяють застосовувати певну функцію до кожного елемента.
- Функції зворотного виклику та закриття часто використовуються з функціями вищого порядку для інкапсуляції поведінки.

Ці основні принципи функціонального програмування разом спрямовані на те, щоб зробити код більш надійним, зручним для обслуговування та легшим для розуміння.
Застосовуючи незмінність, чисті функції та функції вищого порядку, функціональне програмування заохочує декларативний і стислий стиль кодування, який добре підходить для таких завдань, як автоматизоване тестування.

<a 
    name="як-концепції-функціонального-програмування-можуть-покращити-автоматизоване-тестування" 
    id="як-концепції-функціонального-програмування-можуть-покращити-автоматизоване-тестування" 
/>

Концепції функціонального програмування можуть значно покращити автоматизоване тестування наступними способами:

1. Передбачуваність і можливість тестування:
- Чисті функції у функціональному програмуванні виробляють узгоджені та передбачувані виходи для тих самих вхідних даних, що полегшує написання тестів і затвердження очікуваних результатів.
- Ця передбачуваність спрощує процес виявлення та усунення помилок.
2. Ремонтопридатність:
- Незмінність перешкоджає модифікації даних після їх створення. Під час тестування це означає, що після визначення налаштування тесту воно не буде випадково змінюватися під час виконання тесту, що призведе до більш зручних і надійних тестів.
3. Читабельність:
- Функціональне програмування заохочує декларативний та виразний стиль кодування. Тестові сценарії стають більш читабельними та зрозумілими, допомагаючи розробникам і тестувальникам зрозуміти логіку тестування.
4. Масштабованість:
- Функціональне програмування полегшує масштабування зусиль автоматизованого тестування. Використання чистих функцій і незмінних структур даних зменшує ймовірність появи помилок у міру зростання вашого набору тестів.
5. Компонування:
- Функції вищого порядку та функціональна композиція дозволяють створювати тестові компоненти для багаторазового використання. Тестові приклади можна створювати шляхом компонування цих компонентів, сприяючи повторному використанню коду та зменшуючи дублювання.
6. Паралельне та одночасне тестування:
- Принципи функціонального програмування добре узгоджуються зі сценаріями паралельного та одночасного тестування. Незмінність і чисті функції усувають перегони даних і забезпечують безпеку потоків, дозволяючи тестам виконуватися одночасно без конфліктів.
7. Обробка помилок:
- Функціональне програмування сприяє належним методам обробки помилок, що полегшує перелов і обробку винятків під час виконання тесту. Це призводить до більш надійних і відмовостійких тестів.
8. Абстракція:
- Функції вищого порядку та функціональна композиція дозволяють абстрагувати загальні шаблони тестування, що робить можливим створення більш загальних і гнучких інфраструктур тестування.
9. Кросбраузерне тестування:
- Функціональне програмування може бути корисним під час кросбраузерного тестування. Послідовний і передбачуваний характер функціонального коду допомагає писати тести, які не залежать від браузера,
дозволяючи вам виконувати ті самі тести в різних браузерах без змін коду.

Включення концепцій функціонального програмування в автоматизоване тестування може призвести до більш ефективних, підтримуваних і надійних інфраструктур тестування.
Це допомагає вирішувати поширені проблеми тестування та заохочує структурований, дисциплінований підхід до написання тестів, зрештою покращуючи якість ваших програмних продуктів.

<a name="переваги-використання-typescript-і-playwright" id="переваги-використання-typescript-і-playwright" />

Використання TypeScript в автоматизованому тестуванні дає кілька переваг, зокрема статичний тип і покращену якість коду:

1. Статичний тип:
- TypeScript забезпечує надійну систему типів, яка дозволяє явно визначати типи змінних і параметрів функції, а також повертати значення.
— Ця статична типізація допомагає виявляти помилки, пов’язані з типом, під час компіляції, а не під час виконання. Це зменшує ймовірність несподіваних помилок, пов’язаних із типом, підвищуючи надійність ваших тестових сценаріїв.
2. Якість коду:
- TypeScript забезпечує дотримання стандартів кодування та передових практик, що призводить до чистішого, більш упорядкованого та добре задокументованого коду. Це покращує якість і читабельність коду, полегшуючи його розуміння та підтримку.
3. Intellisense та автозавершення:
- TypeScript пропонує потужні редактори коду з такими функціями, як intellisense і автозавершення. Ці функції допомагають розробникам і тестувальникам, надаючи пропозиції з урахуванням контексту, зменшуючи ймовірність синтаксичних помилок і прискорюючи розробку коду.
4. Виявлення та запобігання помилкам:
- Компілятор TypeScript виявляє та повідомляє про помилки та попередження під час розробки. Цей ранній зворотний зв’язок запобігає багатьом поширеним помилкам кодування та невідповідностям, що призводить до більш надійних тестових сценаріїв.
5. Рефакторинг і узгодженість коду:
— TypeScript полегшує рефакторинг коду. Ви можете впевнено вносити зміни у свою кодову базу, знаючи, що система типів допоможе ідентифікувати та оновити всі пов’язані сегменти коду, забезпечуючи узгодженість.
6. Покращений інструментарій:
- TypeScript добре підтримується низкою інструментів розробки, включаючи IDE, такі як Visual Studio Code. Ці інструменти забезпечують такі функції, як налагодження, інтеграція контролю версій і потужні розширення, які спрощують процес тестування.
7. Документація та зрозумілий код:
- Анотації типів у TypeScript діють як самодокументований код. Тестові сценарії стають більш зрозумілими, скорочуючи криву навчання для членів команди та роблячи кодову базу більш доступною.
8. Тестування сумісності фреймворку:
- TypeScript можна легко інтегрувати з популярними платформами тестування, такими як Playwright, Jest, Mocha та Jasmine. Ця сумісність дозволяє безперебійно писати та виконувати тести, користуючись перевагами TypeScript.
9. Інтеграція з проектами TypeScript:
- Якщо код вашої програми також написаний на TypeScript, інтегрувати код тестування в той самий проект буде легко. Ви можете обмінюватися текстами та користуватися перевагами єдиної кодової бази.

Таким чином, статична типізація TypeScript і покращення якості коду призводять до більш надійних, придатних для обслуговування та ефективних сценаріїв автоматизованого тестування.
Запобігаючи поширеним помилкам, покращуючи читабельність коду та пропонуючи потужну підтримку інструментів, TypeScript може значно підвищити якість вашої системи тестування.

Playwright пропонує низку переваг, які роблять його чудовим вибором для автоматизованого тестування, зокрема:

1. Підтримка крос-браузерності:
- Playwright підтримує декілька браузерів, зокрема Chromium (Google Chrome), Firefox і WebKit (Safari).
- Ця крос-браузерна сумісність дозволяє запускати ті самі тестові сценарії в різних браузерах, забезпечуючи надійність і узгодженість ваших тестів на різних платформах і обслуговуючи ширшу базу користувачів.
2. Швидке виконання:
- Playwright розроблений для високопродуктивної автоматизації тестування. Він пропонує швидше виконання тестів порівняно з іншими бібліотеками автоматизації.
- Швидкість особливо цінна під час виконання обширних наборів тестів або зосередження на швидкому зворотному зв’язку під час процесу розробки, допомагаючи вам заощадити дорогоцінний час.
3. Уніфікований API:
- Playwright надає уніфікований API для автоматизації різних браузерів. Це означає, що ви можете написати тестові сценарії один раз і виконати їх у кількох браузерах без необхідності переписувати чи адаптувати код для кожного з них.
- Цей уніфікований підхід оптимізує розробку та підтримку тестів, зменшуючи зусилля, необхідні для кросбраузерного тестування.
4. Автоматичне очікування:
- Playwright містить вбудовані механізми для автоматичного очікування, поки веб-елементи з’являться, стануть доступними для натискання або досягнуть певного стану. Ця функція зменшує потребу в ручному коді очікування та підвищує надійність ваших тестів, особливо під час роботи з динамічними веб-додатками.
5. Обробка помилок і налагодження:
- Playwright пропонує комплексну обробку помилок, надаючи докладні повідомлення про помилки та інформацію про стан веб-сторінки на момент виникнення помилки.
- Його можливості налагодження допомагають тестувальникам ефективніше виявляти та діагностувати проблеми, прискорюючи процес налагодження.
6. Безголовий і головний режими:
- Playwright підтримує безголовий (невидимий) і головний (видимий) режими браузера. Ви можете вибрати режим, який відповідає вашим конкретним потребам тестування.
- Безголовий режим корисний для запуску тестів у фоновому режимі, тоді як головний режим дозволяє спостерігати за виконанням тесту в браузері, допомагаючи в налагодженні та розробці тестів.
7. Емуляція мобільного пристрою:
- Playwright дозволяє емулювати мобільні пристрої, роблячи можливим перевірити швидкість реагування веб-додатків на різних розмірах і орієнтаціях екрана.
- Це важливо для того, щоб ваші веб-програми були зручними для мобільних пристроїв.
8. Доступ до API браузера:
- Playwright надає доступ до API браузера та пропонує методи взаємодії з такими функціями, як геолокація, дозволи тощо. Це полегшує сценарії тестування, які включають складну взаємодію з браузером.

Таким чином, підтримка Playwright у різних браузерах, швидке виконання, уніфікований API та додаткові функції для обробки помилок, налагодження та емуляції роблять його потужним вибором для тестування автоматизації.
Його універсальність і покращення продуктивності сприяють ефективності та надійності ваших зусиль з автоматизації тестування.

TypeScript і Playwright можуть бездоганно доповнювати парадигму функціонального програмування в автоматизованому тестуванні, підвищуючи переваги функціонального програмування:

1. TypeScript і жорстка типізація:
— TypeScript забезпечує надійну статичну типізацію, яка добре узгоджується з концепцією безпеки типів функціонального програмування.
- Надійна типізація гарантує, що дані та функції використовуються узгоджено та правильно, зменшуючи ризик пов’язаних із типом помилок у тестових сценаріях.
- Це відповідає принципу передбачуваності та надійності функціонального програмування.
2. Чисті функції та незмінність:
- TypeScript заохочує використання чистих функцій і незмінності. Явно визначаючи типи функцій і охоплюючи незмінність, TypeScript підсилює ці основні концепції функціонального програмування.
- Тестові сценарії, написані на TypeScript, швидше за все, будуть чистими функціями, які не мають побічних ефектів і дають передбачувані результати для заданого набору вхідних даних.
3. Функціональний склад:
- Підтримка TypeScript для функціональної композиції дозволяє тестувальникам комбінувати та об’єднувати функції для створення складних тестових сценаріїв.
- Це узгоджується з принципом функціонального програмування створення менших, чистих функцій для створення більш складних і надійних систем.
4. Зручність читання та обслуговування:
- Надійний тип, чіткий синтаксис і виразний код, які підтримує TypeScript, створюють тестові сценарії, які можна читати та підтримувати.
- У функціональному програмуванні читабельність коду має вирішальне значення, а функції TypeScript сприяють самодокументуванню, чіткому та стислому коду.
5. Інтеграція тестової інфраструктури:
- TypeScript легко інтегрується з популярними платформами тестування. Ви можете писати тестові випадки, використовуючи принципи функціонального програмування, і використовувати переваги надійної типізації TypeScript у своїй системі тестування.
- Ця інтеграція гарантує, що ваші тестові сценарії не тільки функціональні, але й добре інтегровані в загальний робочий процес тестування.
6. Введіть анотації та документацію:
- TypeScript використовує анотації типів, які діють як документація у ваших тестових сценаріях. Це особливо цінно під час дотримання практики функціонального програмування, оскільки це робить код більш зрозумілим і зрозумілим.
- Гарна документація є ключовим елементом функціонального програмування, який допомагає передати зміст коду.
7. Паралельне та одночасне тестування:
- Концепції функціонального програмування, такі як незмінність і чисті функції, полегшують написання одночасного та паралельного коду.
- Система типів TypeScript забезпечує додаткову безпеку під час роботи з паралельним кодом, зменшуючи ризик конкуренції та неузгодженості даних.
8. Обробка помилок:
- І TypeScript, і функціональне програмування наголошують на належній обробці помилок. Поєднання цих концепцій гарантує ефективне керування помилками, що призводить до більш надійних і надійних тестів.

Підсумовуючи, TypeScript і Playwright забезпечують міцну основу для застосування функціонального програмування в автоматизованому тестуванні.
Вони зміцнюють основні принципи функціонального програмування, покращують якість і читабельність коду, а також підвищують загальну надійність і зручність обслуговування тестових сценаріїв. Використовуючи ці технології, тестувальники можуть створити більш ефективну та надійну структуру тестування, яка відповідає парадигмі функціонального програмування.

<a name="висновок" id="висновок" />

У першій частині цієї публікації ми розпочали подорож у світ функціонального програмування в автоматизованому тестуванні.
Ми дослідили основні принципи функціонального програмування, обговорили переваги використання TypeScript і Playwright у цьому контексті та підкреслили, як ці технології доповнюють парадигму функціонального програмування.
Завдяки глибокому розумінню цих концепцій ви тепер краще підготовлені для того, щоб розпочати практичні аспекти створення надійної системи тестування, яка використовує ці принципи.
]]></description>
        </item>
        <item>
            <title><![CDATA[🚀 Використання функціонального програмування для автоматизованого тестування: розкриття нових можливостей 🚀]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/functional-programming-for-automation-testing</link>
            <guid>https://oholsyhevskyi.com/uk/blog/functional-programming-for-automation-testing</guid>
            <pubDate>Tue, 17 Oct 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

Як професіонали із забезпечення якості, наша місія полягає в забезпеченні надійності та продуктивності програмного забезпечення. Автоматизоване тестування є наріжним каменем цього процесу,
і наш підхід до цього може змінити все. Сьогодні давайте заглибимося у світ функціонального програмування та того, як воно впливає на наші зусилля з автоматизованого тестування.

🌟 Сильні сторони функціонального програмування в автоматизованому тестуванні 🌟

1. **Відтворюваність**: функціональне програмування наголошує на незмінності, гарантуючи, що сценарії тестування залишаються узгодженими під час виконання. Це має неоціненне значення для раннього виявлення регресії.
2. **Модульність**: функції є будівельними блоками функціонального програмування. Їх можна легко використовувати повторно, що робить тестовий код більш придатним для обслуговування та адаптації.
3. **Параллельність**: фокус функціонального програмування на чистих функціях забезпечує ефективне паралельне виконання тестів, підвищуючи загальну швидкість тестування.
4. **Обробка помилок**: завдяки вбудованим механізмам обробки помилок, таким як Try-Catch, функціональне програмування спрощує налагодження, полегшуючи виявлення проблем у тестах.
5. **Масштабованість**: функціональні мови створені для масштабованості, яка є важливою, оскільки програми ростуть і розвиваються.

👎 Слабкі сторони функціонального програмування в автоматизованому тестуванні 👎

1. **Крива крива навчання**: для команд із забезпечення якості, які не знайомі з функціональним програмуванням, існує крива навчання. Можливо, знадобляться періоди навчання та адаптації.
2. **Обмеження інструментів і бібліотек**: деякі інструменти тестування автоматизації можуть не повністю підтримувати парадигми функціонального програмування, що обмежує ваш вибір.
3. **Складність**: Хоча функціональний код часто більш стислий, він може бути більш абстрактним і складним, що ускладнює його розуміння для новачків.
4. **Проблеми інтеграції**: інтеграція функціонального коду з існуючими тестовими фреймворками та середовищами може бути складним завданням.

⚙️ Виклики для спеціалістів із забезпечення якості під час впровадження функціонального програмування ⚙️

1. **Культурний зсув**: перехід від традиційного імперативного програмування до функціонального програмування може вимагати культурних зрушень у командах із забезпечення якості.
2. **Вибір інструментів**: вибір правильних інструментів і фреймворків, які підтримують функціональне програмування для автоматизованого тестування, має вирішальне значення.
3. **Технічне обслуговування**: забезпечення того, щоб функціональний тестовий код залишався читабельним і придатним для обслуговування в міру розвитку програми, є постійною проблемою.

🔄 Порівняння функціонального програмування з традиційними підходами 🔄

Традиційне автоматизоване тестування спирається на процедурне та об’єктно-орієнтоване програмування. Поки ці підходи випробувані
і перевірені, іноді вони можуть бути більш жорсткими та менш адаптованими, ніж функціональне програмування.

Функціональне програмування забезпечує гнучкість і масштабованість процесу тестування. Він відмінно працює в динамічних середовищах, що постійно змінюються, де адаптивність є ключовою.
Однак важливо оцінити готовність вашої команди, наявні у вас інструменти та конкретні потреби вашого проекту перед переходом.

Підсумовуючи, функціональне програмування пропонує багатообіцяючий шлях для професіоналів із забезпечення якості в автоматизованому тестуванні. Хоча існують проблеми, переваги відтворюваності,
модульність, паралелізм і масштабованість роблять його переконливим варіантом. Зі зміною світу розробки програмного забезпечення повинні розвиватися і наші методології тестування.
]]></description>
        </item>
        <item>
            <title><![CDATA[🤖 Використання ланцюжкових функцій для автоматизованого тестування за допомогою Playwright і TypeScript 🚀]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/chained-functions-in-test</link>
            <guid>https://oholsyhevskyi.com/uk/blog/chained-functions-in-test</guid>
            <pubDate>Mon, 16 Oct 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

<a name="вступ" id="вступ" />

Представляючи світ «Використання ланцюжкових функцій для автоматизованого тестування з Playwright і TypeScript», ми починаємо подорож, щоб ще 
більше покращити ваші навички автоматизованого тестування.
Як розширення раніше дослідженого шаблону PageObject, ця тема пропонує потужний і ефективний спосіб оптимізувати ваші процеси тестування.
У цьому вичерпному посібнику ми зануримося в концепцію зв’язування функцій на основі модульних тестів автоматизації, які можна підтримувати.
Цей підхід у поєднанні з шаблоном PageObject не тільки зробить ваші тести більш читабельними, але й значно підвищить їх ефективність.

<a href="https://oholsyhevskyi.com/uk/blog/page-object-pattern">Дивіться попередню тему</a>

У нашому попередньому дослідженні ми дізналися, як шаблон PageObject може трансформувати структуру та організацію
автоматизованих тестів шляхом абстрагування інтерфейсів користувача на окремі класи, що призводить до чистішого та більш модульного тестового коду.
Тепер давайте зробимо наступний крок, ввівши концепцію «ланцюжкових функцій». Зв’язані функції забезпечують засоби для виконання
кілька послідовних дій над веб-елементами, що спрощує взаємодію та оптимізує читабельність ваших тестових сценаріїв.
Він пропонує динамічний спосіб навігації різними діями, необхідними для тестування вашої програми.

У цьому посібнику ми дізнаємося, як створити клас Control, який дозволяє об’єднувати функції для ефективної взаємодії з веб-елементами.
Ми розглянемо його реалізацію, досліджуючи, як це спрощує процес тестування та покращує організацію автоматизованих тестів.

Давайте плавно перейдемо від шаблону PageObject до світу зв’язаних функцій, спираючись на основу, закладену в нашому попередньому обговоренні.
Разом ми опануємо мистецтво створення ефективних і добре структурованих автоматизованих тестів за допомогою Playwright і TypeScript. 🚀

<a name="крок-1-клас-control" id="крок-1-клас-control" />

У вашому проекті Playwright створіть клас Control у новому файлі ./src/control/control.ts.

```ts
import { Locator, Page } from '@playwright/test';

class Control {
    private readonly locator: Locator;

    constructor (private readonly selector: string, private readonly page: Page) {
        this.locator = this.page.locator(this.selector);
    }
}

export default Control;
```

Цей клас буде інкапсулювати методи для взаємодії з веб-елементами за допомогою об’єктів Playwright's Locator і Page.

Ви можете виконувати такі дії, як клацання, заповнення полів введення, очищення полів введення та натискання клавіш у цьому класі, а також багато інших дій, які вам потрібні. Давайте додамо деякі з них до нашого класу Control:

```ts
import { Locator, Page } from '@playwright/test';

class Control {
    private readonly locator: Locator;

    constructor (private readonly selector: string, private readonly page: Page) {
        this.locator = this.page.locator(this.selector);
    }

    click = async (): Promise<Control> => {
        await this.locator.click();
        return this;
    }

    fill = async (value: string): Promise<Control> => {
        await this.locator.fill(value);
        return this;
    }

    clear = async (): Promise<Control> => {
        await this.locator.clear();
        return this;
    }

    press = async (key: string): Promise<Control> => {
        await this.locator.press(key);
        return this
    }

    getInputValue = (): Promise<string> => this.locator.inputValue();
}

export default Control;
```

У цьому класі ви визначаєте методи для типових дій, таких як клацання, заповнення, очищення та натискання. Кожен метод повертає екземпляр класу Control, що дозволяє об’єднувати дії разом.

<a name="крок-2-використання-control" id="крок-2-використання-control" />

Тепер інтегруйте клас Control у свій клас PageObject, який представляє певний елемент або частину вашої веб-програми.
У своєму класі PageObject створіть екземпляри класу Control для елементів, з якими ви хочете взаємодіяти.

```ts
import { Page } from "@playwright/test";
import Control from "../../../control/control";

export class TodoApp {
    public readonly newTodoInput: Control = new Control('header > input', this.page);

    constructor (private readonly page: Page) {}
}

export default TodoApp;
```

У цьому прикладі ми створюємо властивість newTodoInput у класі TodoApp, використовуючи клас Control для поля введення, куди можна додавати нові завдання.
Це дозволяє вам легко взаємодіяти з цим елементом у ваших тестах.

<a name="крок-3-написання-тесту" id="крок-3-написання-тесту" />

Створіть тестовий файл у своєму наборі тестів, де ви хочете використовувати підхід ланцюжкових функцій.
У вашому тесті тепер ви можете використовувати екземпляри Control для об’єднання дій для взаємодії з елементами.

```ts
import test, { expect } from './fixtures/fixture';

test.describe('add todo item with chained approach', () => {  
    test('add todo item with chained functions', async ({ todoPage }) => {
        const newTodoItem = 'chainedTodoItem';
        const todo = todoPage.todoApp.newTodoInput;

        await todo
            .fill(newTodoItem)
            .then(() => todo.clear())
            .then(() => todo.fill(newTodoItem))
            .then(() => todo.press('Enter'));

        const leftTodoItems = await todoPage.todoApp.getLeftTodoItems();
        expect(leftTodoItems).toBe(1);
    });
});
```

У цьому тесті ви створюєте екземпляр класу Control для поля введення.
Використовуючи цей екземпляр, ви можете ланцюжок дій, як-от заповнення поля введення, його очищення, заповнення знову та, нарешті, натискання клавіші Enter.
Такий підхід спрощує тестовий код і робить його більш читабельним.

<a name="крок-4-запуск-тесту" id="крок-4-запуск-тесту" />

Тепер ви можете запустити свій тест за допомогою інфраструктури тестування Playwright.
Підхід з ланцюжковими функціями дозволяє вам виконувати низку дій у більш стислий та організований спосіб, що робить ваші тести зручнішими для обслуговування.

Тепер ви можете запустити свої перші тести за допомогою такої команди:

```bash:cmd
npx playwright test
```

Ця команда виконає ваші тести Playwright на основі конфігурації, яку ви встановили у файлі playwright.config.ts.

```bash:output
Running 5 tests using 1 worker
5 passed (12.5s)
```

Виконуючи ці кроки, ви ефективно реалізуєте підхід ланцюжкових функцій у своїх тестах автоматизації Playwright, покращуючи читабельність коду та зручність обслуговування.
Цей підхід особливо корисний, коли вам потрібно виконати кілька дій над одним елементом у сценарії тестування.

<a name="висновок" id="висновок" />

Підхід до ланцюжкових функцій в автоматизованому тестуванні Playwright має як сильні, так і слабкі сторони, які можуть вплинути на ефективність і зручність обслуговування вашого тестового коду.
Нижче наведено підсумок сильних і слабких сторін цього підходу:

<a name="переваги" id="переваги" />

1. Покращена читабельність коду: ланцюгові функції дозволяють виражати послідовність дій над веб-елементом більш інтуїтивно зрозумілим і читабельним способом.
Етапи тестування представлені чітко та організовано.
2. Зменшення коду: ланцюжком дій над одним елементом можна значно зменшити дублювання коду. Це робить ваші тестові сценарії коротшими та лаконічнішими.
3. Модульність: ланцюгові функції спрощують інкапсуляцію та повторне використання логіки взаємодії.
Ви можете створювати багаторазові методи або класи Page Object, які надають плавні та легкі в обслуговуванні інтерфейси для веб-елементів.
4. Легке налагодження: якщо тест не вдається, визначити проблему стає простіше, оскільки помилка зазвичай пов’язана з певною зв’язаною функцією.
Це прискорює налагодження та усунення несправностей.
5. Зменшені відступи: зв’язані функції часто призводять до менших відступів у вашому тестовому коді, що може покращити розбірливість коду.

<a name="недоліки" id="недоліки" />

1. Обмежене паралельне виконання: з’єднання функцій для одного елемента може не працювати належним чином, якщо вам потрібно виконувати одночасні дії з різними елементами або паралельні взаємодії.
У таких випадках вам може знадобитися розірвати ланцюжок і написати окремі рядки коду.
2. Складні сценарії: для складних сценаріїв тестування з кількома елементами та взаємозалежними діями ланцюжок може стати заплутаним.
Можливо, було б корисніше розділити дії та забезпечити ясність за допомогою окремих рядків коду.
3. Обмежена обробка помилок: обробка помилок у зв’язаних функціях може бути складною. Якщо дія в ланцюжку завершується невдало, може бути важко грамотно впоратися з цією конкретною помилкою.
4. Крива навчання: підхід із ланцюжковими функціями може потребувати кривої навчання для членів команди, які вперше знайомляться з цим стилем написання тестових сценаріїв.
Належне навчання та документація важливі для забезпечення ефективного використання.
5. Проблеми обслуговування: надмірне використання ланцюжків для кожної взаємодії може призвести до надто складного коду, який стає складним для підтримки та оновлення в міру розвитку програми.
Важливо знайти баланс між читабельністю та зручністю обслуговування.

На завершення можна сказати, що підхід до ланцюжкових функцій в автоматизованому тестуванні Playwright пропонує значні переваги з точки зору читабельності коду, модульності та зменшення дублювання.
Однак його ефективність залежить від характеру тестових сценаріїв і конкретного випадку використання.
Тестери та інженери з автоматизації повинні ретельно обміркувати, коли і як застосовувати цей підхід, щоб переконатися, що він узгоджується з цілями їх тестування та складністю
f веб-додаток, що тестується.

<a name="ресурси" id="ресурси" />

* [1] повне репо з [кодом](https://github.com/o-holyshevskyi/my-playwright-project);
* [2] об’єкт сторінки [шаблон](https://oholsyhevskyi.com/posts/page-object-pattern);
* [3] драматург [документація](https://playwright.dev/docs/intro);



У наступній темі ми розглянемо, як використовувати підхід каналу з fp-ts для створення функцій і покращення зручності обслуговування та читабельності тестів автоматизації Playwright.

[fp-ts](https://gcanti.github.io/fp-ts/), або функціональне програмування для TypeScript, — це бібліотека, яка передає принципи функціонального програмування в TypeScript. Він пропонує інструменти для написання коду, який є більш передбачуваним, складним і лаконічним.]]></description>
        </item>
        <item>
            <title><![CDATA[🔍 Вивчення шаблону PageObject для автоматизованого тестування 🤖]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/page-object-pattern</link>
            <guid>https://oholsyhevskyi.com/uk/blog/page-object-pattern</guid>
            <pubDate>Fri, 13 Oct 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

Ви тестувальник програмного забезпечення, який прагне оптимізувати свої автоматизовані тести та зробити їх зручнішими та читабельнішими? Якщо так, то шаблон PageObject може бути вашою секретною зброєю! 🛠️

Шаблон PageObject — це шаблон проектування, який покращує організацію та структуру ваших тестів автоматизації. Він абстрагує інтерфейс користувача на окремі класи або об’єкти, роблячи ваш тестовий код чистішим, модульнішим і простішим у обслуговуванні. Розглянемо цей шаблон на простому прикладі за допомогою [**Playwright**](https://playwright.dev/) і [**TypeScript**](https://www.typescriptlang.org/).

У цій публікації я крок за кроком, починаючи з нуля, розповім вам, як створити свій перший проект Playwright. Я покажу вам, як створити об’єктно-орієнтований шаблон Page і як написати свій перший тест за допомогою об’єкта Page. Почнемо з базового налаштування.

<a name="крок-1-базове-налаштування" id="крок-1-базове-налаштування" />

<a name="nodejs" id="nodejs" />

Перш за все, переконайтеся, що на вашій робочій станції встановлено Node.js. Відкрийте командний рядок і виконайте таку команду:

```bash:cmd
node -v
```

Результат має відображати версію Node.js, встановлену на вашій локальній машині. Якщо цього не сталося, переконайтеся, що [**встановили**](https://nodejs.org/en/download) Node.js на своєму комп’ютері.

<a name="playwright" id="playwright" />

Щоб отримати докладнішу інформацію про різні способи інсталяції Playwright на вашій локальній машині, ви можете звернутися до [**документації**](https://playwright.dev/docs/intro#installing-playwright). Однак я продемонструю базовий підхід із використанням пакетів npm.

<a name="створення-каталогу" id="створення-каталогу" />

Щоб створити кореневий каталог для вашого проекту за допомогою командного рядка, виконайте такі дії:

1. Відкрийте командний рядок.
2. Перейдіть до розташування, де ви хочете створити каталог проекту. Ви можете скористатися командою cd, щоб змінити поточний робочий каталог.
3. Створіть новий каталог за допомогою команди mkdir. Наприклад, щоб створити каталог із назвою "my-dramaturg-project", ви можете використати:

```bash:cmd
mkdir my-playwright-project
```

Це створить каталог із вказаною назвою у вашому поточному місці. Потім ви можете перейти до цього каталогу за допомогою
команду cd, щоб розпочати налаштування вашого проекту Playwright у ньому.

```bash:cmd
cd .\my-playwright-project\
```

<a name="встановлення-playwright" id="встановлення-playwright" />

Ви можете встановити Playwright за допомогою команди npm. Виконайте таку команду в командному рядку:

```bash:cmd
npm init playwright@latest
```

Дотримуйтесь інструкцій, які з’являються під час виконання цієї команди, щоб завершити процес інсталяції.
Якщо ви вибрали варіант false для встановлення браузерів і хочете встановити Chromium, виконайте таку команду:

```bash:cmd
npx playwright install chromium
```

Це встановить браузер Chromium для вашого проекту Playwright.

<a name="налаштування-playwright-проекту" id="налаштування-playwright-проекту" />

Давайте виконаємо просту конфігурацію для нашого проекту Playwright. Перейдіть до файлу **playwright.config.ts** і внесіть такі зміни:

```ts:playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : 1,
  reporter: 'html',
  use: {
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
});
```

У цьому оновленому конфігураційному файлі ми спростили його, видаливши коментарі, наразі встановивши лише одного робочого елемента (пізніше ми ввімкнемо паралельну роботу),
і видалення непотрібних проектів, які ми не будемо використовувати. Ці зміни мають зробити вашу конфігурацію Playwright більш простою.

Тепер ви можете запустити свої перші тести за допомогою такої команди:

```bash:cmd
npx playwright test
```

Ця команда виконає ваші тести Playwright на основі конфігурації, яку ви встановили у файлі **playwright.config.ts**.

```bash:output
Running 2 tests using 1 worker
  2 passed (10.2s)
```

<a name="крок-2-шаблон-обєкта-сторінки" id="крок-2-шаблон-обєкта-сторінки" />

Давайте розглянемо структуру за замовчуванням, яку пропонує Playwright із коробки. Відкрийте файл **./tests/example.spec.ts**, щоб побачити, як a
типовий тест для драматурга структурований.

```ts:./tests/example.spec.ts
import { test, expect } from '@playwright/test';

test('has title', async ({ page }) => {
  await page.goto('https://playwright.dev/');

  // Expect a title "to contain" a substring.
  await expect(page).toHaveTitle(/Playwright/);
});

test('get started link', async ({ page }) => {
  await page.goto('https://playwright.dev/');

  // Click the get started link.
  await page.getByRole('link', { name: 'Get started' }).click();

  // Expects page to have a heading with the name of Installation.
  await expect(page.getByRole('heading', { name: 'Installation' })).toBeVisible();
});
```

Структура тесту за замовчуванням у Playwright може мати деякі недоліки:

1. Дублювання коду: часто можна побачити повторюваний код для взаємодії з тими самими елементами в кількох тестах, що може призвести до проблем з обслуговуванням.
2. Крихкі тести: якщо локатор або поведінка елемента змінюється, вам потрібно оновити його в кількох місцях, що робить тести більш крихкими та схильними до зламів.
3. Обмежена можливість повторного використання: існує обмежена можливість повторного використання коду для взаємодії з елементами, що ускладнює спільний доступ до логіки взаємодії між різними тестами.

Ось тут і з’являється шаблон об’єкта сторінки, щоб вирішити ці проблеми. Шаблон об’єкта сторінки надає кілька переваг:

1. Абстракція: вона абстрагує взаємодії інтерфейсу користувача та локатори в окремі класи, роблячи тести більш читабельними та зручними для обслуговування.
2. Повторне використання коду: Ви можете повторно використовувати ці класи Page Object у кількох тестах, зменшуючи дублювання та покращуючи послідовність.
3. Легке обслуговування: якщо локатор або поведінка елемента змінюється, вам потрібно оновити його лише в одному місці, у класі Page Object, який автоматично поширюватиметься
зміна всіх тестів, які використовують цей об’єкт сторінки.
4. Покращена співпраця: команди можуть працювати ефективніше, розділяючи обов’язки між тестовим кодом і кодом Page Object, що дозволяє паралельну розробку.

У наступних кроках ми розглянемо, як застосувати шаблон об’єкта Page у ваших тестах Playwright, щоб реалізувати ці переваги.

<a name="реалізація-обєкта-сторінки" id="реалізація-обєкта-сторінки" />

Щоб ефективно реалізувати шаблон об’єкта сторінки, дуже важливо спочатку зрозуміти веб-програму, яку ви будете автоматизувати. Давайте переглянемо ваш демо-сайт
маєте намір охопити своїми тестами автоматизації, які є https://demo.playwright.dev/todomvc/#/.

Під час відвідування веб-сайту здається, що це програма TodoMVC, поширений приклад для тестування веб-автоматизації. Ось деякі з елементів і функцій
ви можете розглянути тестування:

* Поле введення Todo: тут ви можете вводити нові завдання.
* Кнопка «Додати»: натискання цієї кнопки має додати введене завдання до списку.
* Список завдань: це список завдань, у якому ви можете позначити завдання як завершені або видалити їх.
* Прапорець: ви можете встановити або зняти прапорець біля завдання, щоб позначити його як завершене або невиконане.
* Кнопка «Очистити виконане». Ця кнопка дозволяє очистити всі виконані завдання зі списку.
* Лічильник: показує кількість завдань у списку.
* Фільтри: веб-сайт пропонує фільтри для перегляду всіх, активних або виконаних завдань.

Щоб реалізувати шаблон об’єкта сторінки, ви створите окремі класи об’єктів сторінки для кожного з цих елементів або функцій. Кожен клас Page Object
має інкапсулювати взаємодії та методи, пов’язані з цією конкретною частиною сторінки.

Цей структурований підхід зробить ваші тести більш модульними, придатними для обслуговування та багаторазового використання. У наступних кроках ми можемо розглянути, як створити Page Object
класи для цих елементів і пишіть тести за допомогою шаблону Page Object.

<a name="основна-сторінка" id="основна-сторінка" />

Створення базового класу сторінки є хорошою практикою під час реалізації шаблону об’єкта сторінки. Цей базовий клас сторінки міститиме загальні методи та елементи
які спільно використовуються на кількох сторінках вашої веб-програми. Почнемо зі створення базової сторінки для вашої програми TodoMVC.

```ts:./src/pages/base-page.ts
import { Page, Response } from '@playwright/test';

class BasePage {
    private readonly url: string = 'https://demo.playwright.dev/todomvc/#/'
    constructor(protected readonly page: Page) {}

    get title(): Promise<string> {
        return this.page.title();
    }

    get pageUrl(): string {
        return this.page.url();
    }

    goto = (): Promise<Response | null> => this.page.goto(this.url);
    
}

export default BasePage;
```

Тепер, коли у нас є базова сторінка, яка містить метод дії для відкриття нашої сторінки через URL-адресу, а також дві властивості для отримання заголовка сторінки та поточної URL-адреси,
давайте створимо тести для перевірки заголовка та URL-адреси. Ми збираємося запровадити два тести, оскільки ми перевіряємо різні критерії.

```ts:./tests/example.spec.ts
import { test, expect } from '@playwright/test';
import BasePage from '../src/pages/base-page';

test('has title', async ({ page }) => {
  const basePage = new BasePage(page);
  await basePage.goto();
  
  expect(await basePage.title).toBe('React • TodoMVC');
});

test('get current url', async ({ page }) => {
  const basePage = new BasePage(page);
  await basePage.goto();
  
  expect(basePage.pageUrl).toContain('demo.playwright.dev');
});
```

Щоб запустити ці тести, скористайтеся командним рядком і перевірте, чи вони пройшли чи не пройшли. Сподіваюся, вони пройдуть.

Однак у нас все ще є деякі дублювання. Давайте спростимо тести, щоб уникнути надмірності.
Давайте використаємо під капотом хук beforeEach, наданий Playwright.

```ts:./tests/example.spec.ts
import { test, expect } from '@playwright/test';
import BasePage from '../src/pages/base-page';

var basePage: BasePage;

test.describe('my first page object pattern tests', () => {
  test.beforeEach(async ({ page }) => {
    basePage = new BasePage(page);
    await basePage.goto();
  });
  
  test('has title', async () => expect(await basePage.title).toBe('React • TodoMVC'));
  test('get current url', async () => expect(basePage.pageUrl).toContain('demo.playwright.dev'));  
});
```

Як ви можете бачити, наші тести тепер написані в більш стислому форматі з лише одним рядком для кожного тесту, що є покращенням порівняно з попереднім.

<a name="створіть-todopage" id="створіть-todopage" />

Давайте розглянемо сценарій, коли наша веб-програма складається з кількох сторінок. Щоб керувати цією складністю, кожна сторінка має бути представлена окремим класом.
Наведений нижче код демонструє об’єкт Page для головної сторінки завдань.

```ts:./src/pages/todo-page/todo-page.ts
import { Page } from "@playwright/test";
import BasePage from "../base-page";

class TodoPage extends BasePage {
    constructor(page: Page) {
        super(page);
    }
}

export default TodoPage;
```

У цьому фрагменті коду ми розширюємо шаблон об’єкта сторінки, щоб створити спеціальний клас об’єкта сторінки для головної сторінки завдань у нашому веб-додатку.
Це допомагає організувати наш код і забезпечує чітке розділення проблем.

Ось що відбувається в коді:

1. Ми імпортуємо необхідні модулі та залежності, включаючи клас Page і ваш клас BasePage.
2. Ми створюємо новий клас TodoPage, який розширює BasePage. Це дозволяє TodoPage успадковувати загальні методи та елементи з класу BasePage.
3. У конструкторі ми передаємо екземпляр Page методу super() для ініціалізації BasePage.
4. Розширюючи BasePage, ми можемо додавати спеціальні методи та елементи, пов’язані з головною сторінкою завдань, що полегшує написання тестів для цієї конкретної частини нашої веб-програми.

Цей підхід сприяє повторному використанню коду та зручності обслуговування, оскільки ми можемо створювати окремі класи Page Object для різних сторінок у нашій програмі,
підтримуючи наш тестовий код чистим і організованим.

<a name="створення-елементів-сторінки-todo" id="створення-елементів-сторінки-todo" />

Як згадувалося раніше, добре створювати окремі класи об’єктів сторінки для кожного елемента чи функції у вашій веб-програмі.
Почнемо зі створення класу Page Object для елемента "TodoApp".

```ts:./src/pages/todo-page/page-elements/todo-app.ts
import { Locator, Page } from "@playwright/test";

export class TodoApp {
    private readonly newTodoItem: Locator = this.page.locator('header > input');
    private readonly leftTodoItems: Locator = this.page.locator('//*[@data-testid="todo-count"]/strong');

    constructor (private readonly page: Page) {}

    addNewItem = async (newItem: string): Promise<void> => {
        await this.newTodoItem.fill(newItem);
        return this.page.keyboard.press('Enter');
    }

    addNewItems = async (newItems: string[]): Promise<void> => {
        for (let i = 0; i < newItems.length; i++) {
            const newItem = newItems[i];
            await this.addNewItem(newItem);
        }
    }

    getLeftTodoItems = async (): Promise<number> => {
        return Number(await this.leftTodoItems.innerText());
    }
}

export default TodoApp;
```

Ми створили клас Page Object для елемента "TodoApp" у нашій веб-програмі, що є чудовим способом інкапсуляції взаємодії та методів
пов'язані з цим конкретним елементом. Давайте підсумуємо ключові моменти коду:

1. Ми визначили клас TodoApp, який представляє елемент "TodoApp".
2. Усередині конструктора ми ініціалізували два локатори, newTodoItem і leftTodoItems, які використовуються для пошуку певних елементів у «TodoApp».
3. Ми створили методи для взаємодії з елементом "TodoApp":
* addNewItem дозволяє нам додати новий елемент до списку завдань, заповнивши поле введення та натиснувши Enter.
* addNewItems — це службовий метод для додавання кількох елементів шляхом повторного виклику addNewItem.
* getLeftTodoItems отримує кількість завдань, що залишилися, що корисно для перевірки, чи елементи додаються та позначаються як завершені.

Цей клас Page Object ефективно інкапсулює взаємодію з елементом "TodoApp" і забезпечує простий і модульний спосіб написання
тести для цієї частини вашої веб-програми. Це хороша практика для підтримки зрозумілих і придатних для обслуговування тестів автоматизації.

Давайте включимо цей "TodoApp" до нашої "TodoPage", виконайте наведений нижче код:

```ts:/src/pages/todo-page/todo-page.ts
import { Locator, Page } from "@playwright/test";
import BasePage from "../base-page";
import TodoApp from "./page-elements/todo-app";

class TodoPage extends BasePage {
    public pageHeader: Locator = this.page.locator('h1');
    public todoApp: TodoApp = new TodoApp(this.page);

    constructor(page: Page) {
        super(page);
    }
}

export default TodoPage;
```

Ми успішно включили об’єкт сторінки TodoApp у нашу сторінку TodoPage. Ось короткий перелік змін у коді:

1. Ми імпортували клас TodoApp Page Object.
2. Ми створили загальнодоступну властивість todoApp та ініціалізували її новим екземпляром об’єкта сторінки TodoApp у конструкторі.

Завдяки цим змінам ми тепер маємо доступ до методів і елементів, визначених у класі TodoApp, із нашої TodoPage.
Це робить наш код більш організованим і дотримується шаблону об’єкта сторінки, дозволяючи нам взаємодіяти з елементом «TodoApp» у контексті головної сторінки завдань.

<a name="тест-після-змін" id="тест-після-змін" />

Щоб написати новий тест після змін, ви можете створити новий тестовий файл із назвою, яка закінчується на .spec.ts, щоб вказати, що це тестовий файл.
Ось приклад того, як створити тест для вашої "TodoPage" за допомогою Playwright:

```ts:./tests/add-new-todo-items.spec.ts
import { test, expect } from '@playwright/test';
import TodoPage from '../src/pages/todo-page/todo-page';

var todoPage: TodoPage;

test.describe('my first page object pattern tests', () => {
  test.beforeEach(async ({ page }) => {
    todoPage = new TodoPage(page);
    await todoPage.goto();
  });
  
  test('add single todo item', async () => {
    await todoPage.todoApp.addNewItem('newTodoItem');
    const leftTodoItems = await todoPage.todoApp.getLeftTodoItems();
    expect(leftTodoItems).toBe(1);
  });

  test('add multiple todo items', async () => {
    const newItems: string[] = ['newTodoItem1', 'newTodoItem2'];
    await todoPage.todoApp.addNewItems(newItems);
    const leftTodoItems = await todoPage.todoApp.getLeftTodoItems();
    expect(leftTodoItems).toBe(newItems.length);
  });  
});
```

Ми створили тестовий файл, використовуючи правила іменування .spec.ts, і організували наші тести за допомогою хуків describe і test.beforeEach.
Ця структура відповідає шаблону Page Object і робить наші тести більш організованими та модульними.

Ось короткий виклад нашого тестового коду:

1. Ми імпортуємо необхідні модулі, включаючи тестування та очікування від Playwright, а також функцію опису.
2. Ми створюємо екземпляр TodoPage для використання в наших тестах і використовуємо хук test.beforeEach для переходу на сторінку перед кожним тестом.
3. Ми організували наші тести в блок опису, який допомагає згрупувати пов’язані тести.
4. У першому тесті ми додаємо один елемент Todo, перевіряємо, чи його додано, і перевіряємо кількість завдань, що залишилися.
5. У другому тесті ми додаємо кілька завдань, перевіряємо, чи їх додано, і перевіряємо кількість завдань, що залишилися.

Ця структура є чудовим способом реалізації шаблону об’єкта сторінки та гарантує, що наші тести є зручними та модульними.

Зачекай! Ми все ще маємо дубльований код у двох тестових файлах:

```ts:example.spec.ts
var basePage: BasePage;

test.beforeEach(async ({ page }) => {
    basePage = new BasePage(page);
    await basePage.goto();
});
```
and
```ts:add-new-todo-items.spec.ts
var todoPage: TodoPage;

test.beforeEach(async ({ page }) => {
    todoPage = new TodoPage(page);
    await todoPage.goto();
});
```

Ми все ще можемо спростити його, щоб використовувати [**фікстури**](https://playwright.dev/docs/test-fixtures#introduction).

Тестові прилади використовуються для встановлення середовища для кожного тесту, надаючи тесту все, що йому потрібно, і нічого більше. Отже, як ми можемо спростити наші два файли зі світильниками.

Давайте створимо новий файл **./tests/fixtures/fixture.ts** у нашій папці **tests**:

```ts:./tests/fixtures/fixture.ts
import { test as base } from '@playwright/test';
import TodoPage from '../../src/pages/todo-page/todo-page';

type Fixture = {
    todoPage: TodoPage;
}

const test = base.extend<Fixture>({
    todoPage: async ({ page }, use) => {
      const todoPage = new TodoPage(page);
      await todoPage.goto();
      await use(todoPage);
    },
});

export default test;
export { expect } from '@playwright/test';
```

Ми створили файл фікстури, щоб спростити налаштування нашого тесту, що є чудовим підходом для усунення дублювання. Давайте переглянемо зміни:

У нашому файлі ./tests/fixtures/fixture.ts:

1. Ми імпортуємо тест із Playwright, щоб визначити наш тест.
2. Ми визначаємо тип приладу, щоб визначити, що забезпечує прилад. У цьому випадку він надає екземпляр todoPage TodoPage.
3. Ми створюємо функцію тестового розширення, яка встановлює сторінку todoPage і передає її тесту.
4. Функція use використовується для надання екземпляра todoPage для тесту.
5. Ми експортуємо тестовий прилад і функцію очікування з Playwright для використання в наших тестах.

Завдяки такому налаштуванню наш тестовий код спрощується. Цей підхід відповідає найкращим практикам і покращує зручність обслуговування вашого тестового коду.
Давайте подивимося, як це працює.

тоді
```ts:example.spec.ts
import { test, expect } from '@playwright/test';
import BasePage from '../src/pages/base-page';

var basePage: BasePage;

test.describe('my first page object pattern tests', () => {
  test.beforeEach(async ({ page }) => {
    basePage = new BasePage(page);
    await basePage.goto();
  });
  
  test('has title', async () => expect(await basePage.title).toBe('React • TodoMVC'));
  test('get current url', async () => expect(basePage.pageUrl).toContain('demo.playwright.dev'));  
});
```
тепер
```ts:example.spec.ts
import test, { expect } from './fixtures/fixture';

test.describe('my first page object pattern tests', () => {
  test('has title', async ({ todoPage }) => expect(await todoPage.title).toBe('React • TodoMVC'));
  test('get current url', async ({ todoPage }) => expect(todoPage.pageUrl).toContain('demo.playwright.dev'));  
});
```
тоді
```ts:add-new-todo-items.spec.ts
import { test, expect } from '@playwright/test';
import TodoPage from '../src/pages/todo-page/todo-page';

var todoPage: TodoPage;

test.describe('my first page object pattern tests', () => {
  test.beforeEach(async ({ page }) => {
    todoPage = new TodoPage(page);
    await todoPage.goto();
  });
  
  test('add single todo item', async () => {
    await todoPage.todoApp.addNewItem('newTodoItem');
    const leftTodoItems = await todoPage.todoApp.getLeftTodoItems();
    expect(leftTodoItems).toBe(1);
  });

  test('add multiple todo items', async () => {
    const newItems: string[] = ['newTodoItem1', 'newTodoItem2'];
    await todoPage.todoApp.addNewItems(newItems);
    const leftTodoItems = await todoPage.todoApp.getLeftTodoItems();
    expect(leftTodoItems).toBe(newItems.length);
  });  
});
```
тепер
```ts:add-new-todo-items.spec.ts
import test, { expect } from './fixtures/fixture';

test.describe('my first page object pattern tests', () => {  
  test('add single todo item', async ({ todoPage }) => {
    await todoPage.todoApp.addNewItem('newTodoItem');
    const leftTodoItems = await todoPage.todoApp.getLeftTodoItems();
    expect(leftTodoItems).toBe(1);
  });

  test('add multiple todo items', async ({ todoPage }) => {
    const newItems: string[] = ['newTodoItem1', 'newTodoItem2'];
    await todoPage.todoApp.addNewItems(newItems);
    const leftTodoItems = await todoPage.todoApp.getLeftTodoItems();
    expect(leftTodoItems).toBe(newItems.length);
  });  
});
```

Ми внесли значні покращення, використовуючи прилади для спрощення налаштування тесту. Ось як це працює:

1. Ми створили фікстуру, яка встановлює екземпляр todoPage, усуваючи необхідність створювати його в кожному тесті та, таким чином, зменшуючи дублювання.
2. Ми використали тестову функцію з нашого приладу в наших тестових файлах, і todoPage автоматично надається для кожного тесту.
3. Файли тестування стали чистішими та більше зосередженими на фактичних сценаріях тестування, що робить їх більш читабельними та зручними для обслуговування.

Застосувавши ці зміни, ми покращили структуру наших тестів, дотримувалися найкращих практик і зробили наш тестовий код більш зручним для обслуговування.
Це чудовий приклад того, як ефективно реалізувати шаблон об’єкта сторінки та оптимізувати процес тестування.

<a name="висновок" id="висновок" />

Я надав детальний посібник із впровадження шаблону об’єкта Page в автоматизованому тестуванні за допомогою Playwright і TypeScript.
Цей шаблон справді є цінним інструментом для покращення організації тестового коду, можливості повторного використання та обслуговування.
Ці покрокові інструкції полегшують тестерам, особливо тим, хто вперше знайомиться з цією концепцією, зрозуміти й ефективно застосувати шаблон об’єкта сторінки.

Додавання фікстур є чудовим покращенням, зменшуючи дублювання коду та спрощуючи налаштування тесту.
Такий підхід покращує ясність і придатність тестових файлів.

Цей посібник є цінним ресурсом для тих, хто хоче створити ефективні та добре структуровані автоматизовані тести за допомогою Playwright і TypeScript.
Він висвітлює найкращі практики та забезпечує чіткий шлях для успішної реалізації шаблону об’єкта сторінки. Чудова робота!

<a name="ресурси" id="ресурси" />

* [1] повне репо з [**кодом**](https://github.com/o-holyshevskyi/my-playwright-project);
* [2] TypeScript [**документація**](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html);
* [3] Playwright [**документація**](https://playwright.dev/docs/intro);
]]></description>
        </item>
        <item>
            <title><![CDATA[Розблокування успіху за допомогою розвитку, керованого поведінкою (БДД) 🚀]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/success-with-bdd</link>
            <guid>https://oholsyhevskyi.com/uk/blog/success-with-bdd</guid>
            <pubDate>Fri, 06 Oct 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

Сьогодні я хочу пролити світло на революційний підхід до розробки програмного забезпечення, який змінив спосіб роботи команд і надання цінності своїм клієнтам: розробка, керована поведінкою (BDD - Behavior-Driven Development ). 🌟

🔍 Що таке БДД?

Розвиток, орієнтований на поведінку, — це не просто модне слово; це методологія спільної роботи, яка долає розрив у спілкуванні між розробниками, тестувальниками та бізнес-стейкхолдерами. За своєю суттю БДД зосереджується на розумінні та визначенні бажаної поведінки програмної системи з точки зору кінцевого користувача.

🌐 Чому БДД важливий:

- Чіткість і співпраця: БДД заохочує чітке та стисле спілкування між членами команди. Це дозволяє зацікавленим сторонам висловлювати свої очікування природною мовою, забезпечуючи, щоб усі були на одній сторінці.
- Раннє виявлення проблем: за допомогою БДД тести створюються на основі цих специфікацій поведінки перед початком розробки. Цей ранній цикл зворотного зв’язку вловлює потенційні проблеми, що призводить до вищої якості коду.
- Орієнтація на клієнта: БДД надає пріоритет клієнтському досвіду, зосереджуючись на тому, що має робити програмне забезпечення, а не лише на тому, що воно може робити. Результатом такого підходу є програмне забезпечення, яке краще відповідає потребам користувачів.
- Ефективне технічне обслуговування: сценарії БДД служать живою документацією, що полегшує підтримку та оновлення програмного забезпечення, оскільки вимоги змінюються з часом.

💼 Впровадження БДД у вашій організації:

- Освіта: інвестуйте в навчання та семінари, щоб переконатися, що ваша команда розуміє принципи та практики БДД.
- Інструменти: використовуйте зручні для БДД інструменти, як-от Cucumber, SpecFlow або Behave, для автоматизації тестів і ефективної співпраці.
- Культура: розвивайте культуру співпраці та відкритого спілкування у вашій команді розробників, наголошуючи на спільній власності на якість продукту.

📈 Майбутнє БДД:
Розвиток, орієнтований на поведінку, — це не просто тенденція; це перевірена методологія, яка може допомогти вашій організації швидше постачати краще програмне забезпечення. Оскільки ми продовжуємо використовувати гнучкі практики та DevOps, БДД стає ще більш актуальним для забезпечення відповідності програмного забезпечення бізнес-цілям.

Я закликаю вас усіх вивчити БДД і побачити, як це може змінити ваш процес розробки. Давайте продовжувати впроваджувати інновації та пропонувати виняткові продукти, які захоплюють наших клієнтів!

Якщо у вас є досвід роботи з БДД або ви можете поділитися думками, будь ласка, зробіть це в коментарях. Давайте продовжувати розмову.]]></description>
        </item>
        <item>
            <title><![CDATA[Розкриття потужності модульного тестування: чому, коли та кому це важливо?]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/power-of-unit-testing</link>
            <guid>https://oholsyhevskyi.com/uk/blog/power-of-unit-testing</guid>
            <pubDate>Thu, 05 Oct 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

У швидкоплинному світі розробки програмного забезпечення забезпечення надійності та надійності нашого коду має першорядне значення. Ось тут і вступає в гру модульне тестування – практика, яка може сприяти або перешкоджати успіху проекту. Давайте зануримося в те, чому, коли і хто використовує модульне тестування!

*Навіщо нам потрібне модульне тестування?*

Модульне тестування полягає в тому, щоб розбити ваш код на найменші компоненти, або одиниці, і ретельно їх тестувати окремо. Основною метою модульного тестування є виявлення та усунення проблем на ранніх стадіях циклу розробки. Виявляючи помилки та регресії на початку, ви економите час, зменшуєте витрати та, зрештою, надаєте своїм користувачам стабільніший і якісніший продукт.

*Кого має хвилювати модульне тестування?*

Модульне тестування — це не лише обов’язок інженерів із забезпечення якості чи спеціалізованих тестувальників. Це колективна робота, яка включає кожного члена команди розробників. Розробники, зокрема, відіграють вирішальну роль у написанні та підтримці модульних тестів для коду, який вони створюють. Застосовуючи модульне тестування, розробники можуть контролювати якість свого коду та зменшувати ймовірність появи дефектів.

Крім того, менеджери проектів, власники продуктів і зацікавлені сторони також повинні піклуватися про модульне тестування. Це безпосередньо впливає на успіх проекту, зменшуючи ризик дорогих дефектів на останньому етапі та гарантуючи, що програмне забезпечення відповідає своїм функціональним вимогам.

*Коли ми повинні почати виконувати модульні тести?*

Модульне тестування має бути невід’ємною частиною процесу розробки з самого початку. Як тільки ви починаєте писати код, ви також повинні писати відповідні модульні тести. Цей ітеративний підхід гарантує, що ви виявляєте проблеми, як тільки вони виникають, замість того, щоб дозволяти їм накопичуватися та ставати складнішими для вирішення.

Модульні тести також можуть служити документацією для вашого коду, допомагаючи новим членам команди зрозуміти його поведінку та забезпечуючи систему безпеки під час внесення змін або рефакторингу.

*Сильні сторони модульного тестування:*

- Раннє виявлення помилок: виявлення та виправлення помилок під час розробки економить час і ресурси порівняно з виявленням їх пізніше на етапах тестування чи виробництва.
— Покращена якість коду: написання модульних тестів заохочує розробників писати чистіший, більш модульний і зручний для обслуговування код.
- Запобігання регресії: модульні тести діють як мережа безпеки, запобігаючи повторному введенню відомих проблем під час внесення змін до кодової бази.
- Документація: модульні тести надають живу документацію для вашого коду, допомагаючи розробникам зрозуміти, як він має працювати.

*Слабкі сторони модульного тестування:*

- Забирає багато часу: написання модульних тестів може забирати багато часу, особливо для складних систем, що може збентежити деяких розробників.
- Неповне покриття: досягнення 100% покриття коду за допомогою модульних тестів може бути складним завданням, і все ще можуть бути неперевірені крайні випадки.
- Витрати на технічне обслуговування: у міру розвитку кодової бази модульні тести можуть вимагати оновлення, а невдалі тести можуть стати вузьким місцем.
- Помилкове відчуття безпеки: проходження модульних тестів не гарантує відсутність помилок у програмі; інтеграція та наскрізне тестування також важливі.

Підсумовуючи, модульне тестування є важливою практикою в сучасній розробці програмного забезпечення. Його переваги, такі як раннє виявлення помилок, покращена якість коду та запобігання регресії, значно переважують його недоліки. Це має бути спільна відповідальність між розробниками, тестувальниками та зацікавленими сторонами, починаючи з першого дня вашого проекту. Використовуючи модульне тестування, ви не просто пишете код; Ви створюєте впевненість у надійності та якості свого програмного забезпечення. 🚀]]></description>
        </item>
        <item>
            <title><![CDATA[🚀Підвищення рівня тестування API: відкриття ключових причин, викликів і потужності автоматизації!🌐]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/evaluating-api-testing</link>
            <guid>https://oholsyhevskyi.com/uk/blog/evaluating-api-testing</guid>
            <pubDate>Mon, 02 Oct 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

🔍 Навіщо нам тестування API? 🔍
API (інтерфейси прикладного програмування) служать джерелом життя сучасних програмних програм, полегшуючи обмін даними між різними компонентами. Ось чому тестування API є незамінним:

1. Надійність: API повинні функціонувати послідовно, щоб забезпечити безперебійну роботу програм. Тестування допомагає нам переконатися, що вони роблять.

2. Гарантія інтеграції: у програмах, які покладаються на кілька API, тестування забезпечує плавну взаємодію між різними компонентами.

3. Безпека: уразливості API можуть призвести до витоку даних. Тестування допомагає виявити та усунути недоліки безпеки.

4. Продуктивність: API повинні ефективно обробляти великі навантаження. Тестування допомагає оцінити їх ефективність під час стресу.

5. Обробка помилок: тестування API розкриває, як API обробляють помилки та винятки, забезпечуючи плавну деградацію.

🤔 Виклики для забезпечення якості в тестуванні API 🤔
Тестування API пов’язане зі своїм унікальним набором проблем для спеціалістів із забезпечення якості:

1. Документація: API часто не мають вичерпної документації, що ускладнює розуміння їх функцій.

2. Формати даних. Робота з різними форматами даних (JSON, XML тощо) може бути складною та потребує спеціальних знань.

3. Керування залежностями: API покладаються на зовнішні служби, що ускладнює налаштування тестових середовищ.

4. Контроль версій: зміни у версіях API можуть порушити тестування, вимагаючи постійної адаптації.

5. Тестування нефункціональних аспектів: окрім функціонального тестування, QA має оцінювати нефункціональні аспекти, такі як продуктивність, безпека та масштабованість.

💡 Сила автоматизації в тестуванні API 💡
Автоматизоване тестування відіграє ключову роль у підвищенні ефективності та результативності тестування API:

1. Повторне використання: автоматичні тести можна повторно використовувати в різних збірках, заощаджуючи час і зусилля.

2. Послідовність: автоматизація забезпечує послідовне тестування, зменшуючи людську помилку.

3. Раннє виявлення: автоматичні тести можна інтегрувати в конвеєр CI/CD, виявляючи проблеми на ранніх стадіях циклу розробки.

4. Регресійне тестування: API розвиваються; автоматизація дозволяє проводити швидке регресійне тестування, щоб переконатися, що існуючі функції залишаються незмінними.

5. Тестування продуктивності: автоматизація дозволяє запускати навантажувальні тести для оцінки продуктивності API за різних умов.

Підсумовуючи, тестування API – це не просто необхідність; це стратегічний імператив у сучасному ландшафті розробки програмного забезпечення. Команди із забезпечення якості, озброєні потрібними інструментами та методами автоматизації, можуть впоратися з труднощами та внести значний внесок у створення надійних і надійних API.]]></description>
        </item>
        <item>
            <title><![CDATA[🌱Культивування здорового середовища розвитку: життєво важлива роль QA🌱]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/healthy-development-environment</link>
            <guid>https://oholsyhevskyi.com/uk/blog/healthy-development-environment</guid>
            <pubDate>Mon, 25 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

У динамічному світі розробки програмного забезпечення здорове командне середовище – це не просто приємно мати; це обов’язковий атрибут для успіху. Сьогодні давайте дослідимо, як сприяння позитивній атмосфері приносить користь командам розробників і яку невід’ємну роль у її підтримці відіграють спеціалісти із забезпечення якості. 🤝💼

1. Співпраця, а не конфронтація: у здоровій команді співпраця процвітає. QA долають розрив між розробниками та кінцевими користувачами, забезпечуючи плавне спілкування та розуміння. 🤝🔄

2. Прихильники якості: Інженери з якості є чемпіонами якості. Вони виступають за надійні методи тестування, допомагаючи команді створювати програмне забезпечення, яке не тільки працює, але й перевищує очікування. 🏆📈

3. Постійне вдосконалення: здорові команди приймають культуру постійного вдосконалення. QA визначає вузькі місця, неефективність процесів і області, які потрібно покращити в стратегіях тестування. 📊🔄

4. Раннє виявлення проблем: гострі очі спеціалістів із забезпечення якості виявляють помилки до того, як вони потраплять у виробництво. Це зводить до мінімуму потребу в термінових виправленнях, зменшуючи стрес для розробників. 👀🦠

5. Обмін знаннями: спеціалісти з якості часто володіють різноманітними навичками. Вони сприяють зростанню команди, ділячись кращими практиками тестування та знаннями предметної області. 🧠🔄

6. Підтримуючий відгук: QA надають конструктивний зворотний зв’язок без звинувачень, сприяючи культурі вдосконалення, а не захисту. 📣👂

7. Зосередженість на користувачеві: роль QA виходить за межі функціональних можливостей до взаємодії з користувачем. Вони гарантують, що кінцевий продукт відповідає очікуванням користувачів, підвищуючи задоволеність клієнтів. 🎯👩‍💻👨‍💻

8. Зменшення професійного вигорання: своєчасно виявляючи та зменшуючи ризики, QA допомагає запобігти нічним сеансам гасіння пожежі, зменшуючи виснаження розробників і стрес. 🚒🌃

Створення та підтримка здорового середовища у вашій команді розробників є колективною роботою. Контролери якості є важливою частиною головоломки, вони вносять свій досвід і відданість, щоб забезпечити процвітання команди та створення виняткового програмного забезпечення. 🌟🚀

Якою ви бачите роль QA у вашій команді розробників? Поділіться своїми думками та досвідом у коментарях нижче! Давайте й надалі надавати пріоритет добробуту та якості команди в нашій роботі. 🤗👩‍💻👨‍💻]]></description>
        </item>
        <item>
            <title><![CDATA[🚀Захоплюючі розробки в автоматизованому тестуванні🚀]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/developments-in-automated-testing</link>
            <guid>https://oholsyhevskyi.com/uk/blog/developments-in-automated-testing</guid>
            <pubDate>Mon, 18 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

У міру розвитку технологій розвиваються і наші підходи до розробки програмного забезпечення та забезпечення якості. 🌐🔍 Сьогодні я хочу поділитися деякими думками про останні тенденції в написанні автоматизованих тестів, які революціонізують галузь. 🤖📊

1. Зсув тестування вліво: компанії все більше сприймають ідею зміщення тестування вліво в циклі розробки. Це означає, що тестування більше не є лише відповідальністю команди QA; воно починається на ранніх етапах процесу розвитку. 🔄👩‍💻

2. ШІ та машинне навчання: автоматизація стає розумнішою завдяки інтеграції ШІ та машинного навчання. Ці технології можуть аналізувати величезні обсяги даних, визначати шаблони та допомагати створювати надійніші тестові випадки. 🤖📈

3. Автоматизація тестування без коду: попит на засоби автоматизації тестування без коду зростає. Вони дозволяють тестувальникам і нетехнічним членам команди створювати та підтримувати автоматизовані тести без глибоких знань програмування.   🚫💻

4. Безперервне тестування: із запровадженням DevOps і конвеєрів безперервної інтеграції/безперервного розгортання (CI/CD) безперервне тестування є життєво важливим. Тести автоматизації повинні йти в ногу з частими змінами коду. ⏩🔄

5. Візуальне тестування: інструменти візуального тестування набувають популярності, гарантуючи, що інтерфейс користувача залишається узгодженим на різних платформах і браузерах. 🖥️👀

6. Управління тестовими даними: Управління тестовими даними має вирішальне значення для автоматизації. Інструменти та практики для ефективного керування тестовими даними стають важливими. 📊🗄️

7. Тестування зсуву вправо: окрім простого зсуву вліво, організації тепер зосереджуються на зсуві вправо, що означає моніторинг додатків у виробництві, щоб виявити проблеми раніше, ніж це зроблять користувачі. 🎯🔍

Ці тенденції формують майбутнє автоматизованого тестування, роблячи його більш ефективним, точним і адаптованим до постійно мінливого середовища програмного забезпечення. 🌟💡]]></description>
        </item>
        <item>
            <title><![CDATA[🔍Розкрийте потужність автоматизації тестування в тестуванні програмного забезпечення💻]]></title>
            <link>https://oholsyhevskyi.com/uk/blog/test-automation-testing-power</link>
            <guid>https://oholsyhevskyi.com/uk/blog/test-automation-testing-power</guid>
            <pubDate>Fri, 08 Sep 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[

У сучасному швидкоплинному технологічному світі якість і ефективність не підлягають обговоренню. Ось тут на допомогу приходить Test Automation, яка змінює правила гри. 🚀

🤖 Що таке автоматизація тестування?
Це стратегічне використання автоматизованих сценаріїв та інструментів для виконання повторюваних тестів, що гарантує якість програмного забезпечення без повсякденних ручних зусиль.

✨ Переваги автоматизації тестування:

1. Швидкість: прискорення циклів тестування.

2. Точність: мінімізуйте людські помилки.

3. Ефективність: зосередьтеся на складних сценаріях.

4. Безперервне тестування: плавна інтеграція з DevOps.

🌟 Готові покращити свою тестову гру?
Інвестуйте в інструменти автоматизації тестування, створюйте надійні набори тестів і дивіться, як ваше програмне забезпечення сяє!

💡 Порада: слідкуйте за такими новими тенденціями, як тестування за допомогою штучного інтелекту та обслуговування тестових сценаріїв.

Давайте зробимо ваш профіль виділяючимся серед конкурентного технологічного середовища! 📈💪]]></description>
        </item>
    </channel>
</rss>